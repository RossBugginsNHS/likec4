import { d as defu, t as t$6 } from '../shared/core.DEieYfbG.mjs';
import { t as t$1, a as t$7 } from '../shared/core.BsSXS-_R.mjs';
import { t as t$5 } from '../shared/core.B9BjmjuH.mjs';
import { j as e } from '../shared/core.BuQZczj6.mjs';
import { e as e$3 } from '../shared/core.DRJma0Ol.mjs';
import { a as _type, u as e$2, _ as _stage, d as isDeployedInstance, p as isElementView } from '../shared/core.DH7TXqXf.mjs';
import { t as t$2 } from '../shared/core.CbT8JVYL.mjs';
import { a as t$4, c as computeLikeC4Model } from '../shared/core.23WeDKcI.mjs';
import { a as t$3 } from '../shared/core.h4TqqSC0.mjs';
import { assignTagColors } from '../styles/index.mjs';
import { n as nameFromFqn, d as isSameHierarchy, p as parentFqn } from '../shared/core.6VsRBhGY.mjs';
import { e as e$1 } from '../shared/core.CqAJJpK_.mjs';
import { ModelFqnExpr } from '../types/expression-model.mjs';
import { i as invariant } from '../shared/core.D4npX2q8.mjs';
import { e as exact } from '../shared/core.M9ayqQZa.mjs';
import { FqnRef } from '../types/fqnRef.mjs';

function t(...t){return t$1(Object.fromEntries,t)}

function parseWhere(where) {
  if (e$1(where)) {
    const op = where;
    switch (true) {
      case op.startsWith("tag is not #"):
        return {
          tag: {
            neq: op.replace("tag is not #", "")
          }
        };
      case op.startsWith("tag is #"):
        return {
          tag: {
            eq: op.replace("tag is #", "")
          }
        };
      case op.startsWith("kind is not "):
        return {
          kind: {
            neq: op.replace("kind is not ", "")
          }
        };
      case op.startsWith("kind is "):
        return {
          kind: {
            eq: op.replace("kind is ", "")
          }
        };
      case op.startsWith("source."):
        return {
          operator: parseWhere(
            op.replace("source.", "")
          ),
          participant: "source"
        };
      case op.startsWith("target."):
        return {
          operator: parseWhere(
            op.replace("target.", "")
          ),
          participant: "target"
        };
      default:
        throw new Error(`Unknown where operator: ${where}`);
    }
  }
  if (where.and) {
    return {
      and: t$2(where.and, parseWhere)
    };
  }
  if (where.or) {
    return {
      or: t$2(where.or, parseWhere)
    };
  }
  if (where.not) {
    return {
      not: parseWhere(where.not)
    };
  }
  throw new Error(`Unknown where operator: ${where}`);
}
function $include(...args) {
  return (b) => {
    let expr = b.$expr(args[0]);
    if (args.length === 2) {
      const condition = args[1].where ? parseWhere(args[1].where) : void 0;
      if (condition) {
        expr = {
          where: {
            expr,
            condition
          }
        };
      }
      const custom = args[1].with;
      if (custom) {
        const isElement = ModelFqnExpr.is(expr);
        if (isElement) {
          expr = {
            custom: {
              ...custom,
              expr
            }
          };
        } else {
          expr = {
            customRelation: {
              ...custom,
              expr
            }
          };
        }
      }
    }
    b.include(expr);
    return b;
  };
}
function $exclude(...args) {
  return (b) => {
    let expr = b.$expr(args[0]);
    if (args.length === 2 && args[1].where) {
      const condition = parseWhere(args[1].where);
      expr = {
        where: {
          expr,
          condition
        }
      };
    }
    b.exclude(expr);
    return b;
  };
}
function $style(element, { notation, ...style }) {
  return (b) => b.style({
    targets: (e(element) ? element : [element]).map((e) => b.$expr(e)),
    ...notation ? { notation } : {},
    style: {
      ...style
    }
  });
}
function $autoLayout(layout) {
  return (b) => b.autoLayout(layout);
}
function $rules(...rules) {
  return (b) => rules.reduce((b2, rule) => rule(b2), b);
}

function $deploymentExpr(expr) {
  if (!e$1(expr)) {
    return expr;
  }
  const asTypedDeploymentExpression = (expr2) => {
    return expr2;
  };
  if (expr === "*") {
    return asTypedDeploymentExpression({ wildcard: true });
  }
  if (expr.startsWith("->")) {
    if (expr.endsWith("->")) {
      return asTypedDeploymentExpression({
        inout: $deploymentExpr(expr.replace(/->/g, "").trim())
      });
    }
    return asTypedDeploymentExpression({
      incoming: $deploymentExpr(expr.replace("-> ", ""))
    });
  }
  if (expr.endsWith(" ->")) {
    return asTypedDeploymentExpression({
      outgoing: $deploymentExpr(expr.replace(" ->", ""))
    });
  }
  if (expr.includes(" <-> ")) {
    const [source, target] = expr.split(" <-> ");
    return asTypedDeploymentExpression({
      source: $deploymentExpr(source),
      target: $deploymentExpr(target),
      isBidirectional: true
    });
  }
  if (expr.includes(" -> ")) {
    const [source, target] = expr.split(" -> ");
    return asTypedDeploymentExpression({
      source: $deploymentExpr(source),
      target: $deploymentExpr(target)
    });
  }
  if (expr.endsWith("._")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace("._", "")
      },
      selector: "expanded"
    });
  }
  if (expr.endsWith(".**")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace(".**", "")
      },
      selector: "descendants"
    });
  }
  if (expr.endsWith(".*")) {
    return asTypedDeploymentExpression({
      ref: {
        deployment: expr.replace(".*", "")
      },
      selector: "children"
    });
  }
  return asTypedDeploymentExpression({
    ref: {
      deployment: expr
    }
  });
}

const asTypedExpr = (expr) => {
  return expr;
};
function $expr(expr) {
  if (!e$1(expr)) {
    return expr;
  }
  if (expr === "*") {
    return asTypedExpr({ wildcard: true });
  }
  if (expr.startsWith("->")) {
    if (expr.endsWith("->")) {
      return asTypedExpr({
        inout: $expr(expr.replace(/->/g, "").trim())
      });
    }
    return asTypedExpr({
      incoming: $expr(expr.replace("-> ", ""))
    });
  }
  if (expr.endsWith(" ->")) {
    return asTypedExpr({
      outgoing: $expr(expr.replace(" ->", ""))
    });
  }
  if (expr.includes(" <-> ")) {
    const [source, target] = expr.split(" <-> ");
    return asTypedExpr({
      source: $expr(source),
      target: $expr(target),
      isBidirectional: true
    });
  }
  if (expr.includes(" -> ")) {
    const [source, target] = expr.split(" -> ");
    return asTypedExpr({
      source: $expr(source),
      target: $expr(target)
    });
  }
  if (expr.endsWith("._")) {
    return asTypedExpr({
      ref: {
        model: expr.replace("._", "")
      },
      selector: "expanded"
    });
  }
  if (expr.endsWith(".**")) {
    return asTypedExpr({
      ref: {
        model: expr.replace(".**", "")
      },
      selector: "descendants"
    });
  }
  if (expr.endsWith(".*")) {
    return asTypedExpr({
      ref: {
        model: expr.replace(".*", "")
      },
      selector: "children"
    });
  }
  return asTypedExpr({
    ref: {
      model: expr
    }
  });
}

function mkViewBuilder(view) {
  const viewBuilder = {
    $expr: view[_type] === "deployment" ? $deploymentExpr : $expr,
    autoLayout(autoLayout) {
      view.rules.push({
        direction: autoLayout
      });
      return viewBuilder;
    },
    exclude(expr) {
      view.rules.push({
        exclude: [expr]
      });
      return viewBuilder;
    },
    include(expr) {
      view.rules.push({
        include: [expr]
      });
      return viewBuilder;
    },
    style(rule) {
      view.rules.push(rule);
      return viewBuilder;
    }
    // title(title: string) {
    //   view.title = title
    //   return viewBuilder
    // },
    // description(description: string) {
    //   view.description = description
    //   return viewBuilder
    // }
  };
  return viewBuilder;
}

function ensureObj(value) {
  return e(value) ? t$6(value, (_) => ({})) : value;
}
function validateSpec({ tags, elements, deployments, relationships, ...specification }) {
  const spectags = {};
  if (tags) {
    Object.assign(
      spectags,
      ensureObj(tags)
    );
  }
  const _elements = ensureObj(elements);
  for (const [kind, spec] of t$5(_elements)) {
    if (spec.tags) {
      for (const tag of spec.tags) {
        invariant(tag in spectags, `Invalid specification for element kind "${kind}": tag "${tag}" not found`);
      }
    }
  }
  const _deployments = ensureObj(deployments ?? {});
  for (const [kind, spec] of t$5(_deployments)) {
    if (spec.tags) {
      for (const tag of spec.tags) {
        invariant(
          tag in spectags,
          `Invalid specification for deployment kind "${kind}": tag "${tag}" not found`
        );
      }
    }
  }
  return {
    ...specification,
    tags: spectags,
    elements: _elements,
    deployments: _deployments,
    relationships: ensureObj(relationships ?? {})
  };
}
function builder(_spec, _elements = /* @__PURE__ */ new Map(), _relations = [], _views = /* @__PURE__ */ new Map(), _globals = {
  predicates: {},
  dynamicPredicates: {},
  styles: {}
}, _deployments = /* @__PURE__ */ new Map(), _deploymentRelations = []) {
  const spec = validateSpec(_spec);
  const toLikeC4Specification = () => {
    return {
      elements: structuredClone(spec.elements),
      deployments: structuredClone(spec.deployments),
      relationships: structuredClone(spec.relationships),
      tags: assignTagColors(structuredClone(spec.tags)),
      ...spec.metadataKeys ? { metadataKeys: spec.metadataKeys } : {},
      customColors: {}
    };
  };
  const mapLinks = (links) => {
    if (!links || !t$7(links, 1)) {
      return void 0;
    }
    return t$2(links, (l) => typeof l === "string" ? { url: l } : l);
  };
  const createGenericView = (id, _props, builder2) => {
    if (e$3(_props)) {
      builder2 = _props;
      _props = {};
    }
    _props ??= {};
    const {
      links: _links = [],
      title = null,
      description = null,
      tags = [],
      ...props
    } = typeof _props === "string" ? { title: _props } : { ..._props };
    const links = mapLinks(_links);
    return [
      exact({
        id,
        title,
        description: description ? { txt: description } : null,
        tags,
        links,
        _stage: "parsed",
        ...props
      }),
      builder2
    ];
  };
  const self = {
    get Types() {
      throw new Error("Types are not available in runtime");
    },
    clone: () => {
      return builder(
        structuredClone(spec),
        structuredClone(_elements),
        structuredClone(_relations),
        structuredClone(_views),
        structuredClone(_globals),
        structuredClone(_deployments),
        structuredClone(_deploymentRelations)
      );
    },
    __addElement: (element) => {
      const parent = parentFqn(element.id);
      if (parent) {
        invariant(
          _elements.get(parent),
          `Parent element with id "${parent}" not found for element with id "${element.id}"`
        );
      }
      if (_elements.has(element.id)) {
        throw new Error(`Element with id "${element.id}" already exists`);
      }
      _elements.set(element.id, element);
      return self;
    },
    __addRelation(relation) {
      const sourceEl = _elements.get(FqnRef.flatten(relation.source));
      invariant(sourceEl, `Element with id "${relation.source.model}" not found`);
      const targetEl = _elements.get(FqnRef.flatten(relation.target));
      invariant(targetEl, `Element with id "${relation.target.model}" not found`);
      invariant(
        !isSameHierarchy(sourceEl, targetEl),
        "Cannot create relationship between elements in the same hierarchy"
      );
      _relations.push({
        id: `rel${_relations.length + 1}`,
        ...relation
      });
      return self;
    },
    __fqn(id) {
      invariant(id.trim() !== "", "Id must be non-empty");
      return id;
    },
    __deploymentFqn(id) {
      invariant(id.trim() !== "", "Id must be non-empty");
      return id;
    },
    __addSourcelessRelation() {
      throw new Error("Can be called only in nested model");
    },
    __addView: (view) => {
      if (_views.has(view.id)) {
        throw new Error(`View with id "${view.id}" already exists`);
      }
      if (isElementView(view) && "viewOf" in view) {
        invariant(
          _elements.get(view.viewOf),
          `Invalid scoped view ${view.id}, wlement with id "${view.viewOf}" not found`
        );
      }
      _views.set(view.id, view);
      return self;
    },
    __addDeployment: (node) => {
      if (_deployments.has(node.id)) {
        throw new Error(`Deployment with id "${node.id}" already exists`);
      }
      const parent = parentFqn(node.id);
      if (parent) {
        invariant(
          _deployments.get(parent),
          `Parent element with id "${parent}" not found for node with id "${node.id}"`
        );
      }
      if (isDeployedInstance(node)) {
        invariant(parent, `Instance ${node.id} of ${node.element} must be deployed under a parent node`);
        invariant(
          _elements.get(node.element),
          `Instance "${node.id}" references non-existing element "${node.element}"`
        );
      }
      _deployments.set(node.id, node);
      return self;
    },
    __addDeploymentRelation: (relation) => {
      invariant(
        !isSameHierarchy(relation.source.deployment, relation.target.deployment),
        "Cannot create relationship between elements in the same hierarchy"
      );
      invariant(
        _deployments.has(relation.source.deployment),
        `Relation "${relation.source.deployment} -> ${relation.target.deployment}" references non-existing source`
      );
      invariant(
        _deployments.has(relation.target.deployment),
        `Relation "${relation.source.deployment} -> ${relation.target.deployment}" references non-existing target`
      );
      _deploymentRelations.push({
        id: `deploy_rel${_deploymentRelations.length + 1}`,
        ...relation
      });
      return self;
    },
    build: (project) => ({
      [_stage]: "parsed",
      projectId: project?.id ?? "from-builder",
      project: {
        id: "from-builder",
        ...project
      },
      specification: toLikeC4Specification(),
      elements: t(
        structuredClone(
          Array.from(_elements.entries())
        )
      ),
      relations: t$4(_relations, (r) => [r.id, structuredClone(r)]),
      globals: structuredClone(_globals),
      deployments: {
        elements: t(
          structuredClone(
            Array.from(_deployments.entries())
          )
        ),
        relations: t$4(_deploymentRelations, (r) => [r.id, structuredClone(r)])
      },
      views: t(
        structuredClone(
          Array.from(_views.entries())
        )
      ),
      imports: {}
    }),
    toLikeC4Model: (project) => {
      const parsed = self.build(project);
      return computeLikeC4Model(parsed);
    },
    helpers: () => ({
      model: {
        model: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        rel: (source, target, _props) => {
          return (b) => {
            const {
              title = "",
              links: _links = [],
              description = null,
              ...props
            } = defu(
              typeof _props === "string" ? { title: _props } : { ..._props },
              { title: null, links: null }
            );
            const links = mapLinks(_links);
            b.__addRelation(exact({
              source: {
                model: source
              },
              target: {
                model: target
              },
              title,
              ...description && { description: { txt: description } },
              links,
              ...props
            }));
            return b;
          };
        },
        relTo: (target, _props) => {
          return (b) => {
            const {
              title = "",
              links,
              description = null,
              ...props
            } = defu(
              typeof _props === "string" ? { title: _props } : { ..._props },
              { title: null, links: null }
            );
            b.__addSourcelessRelation(exact({
              target: {
                model: target
              },
              title,
              ...description && { description: { txt: description } },
              links: mapLinks(links),
              ...props
            }));
            return b;
          };
        },
        ...t$3(
          spec.elements,
          ({ style: specStyle, ...spec2 }, kind) => (id, _props) => {
            const add = ((b) => {
              const {
                links,
                icon: _icon,
                color,
                shape,
                style,
                title,
                description,
                summary,
                ...props
              } = typeof _props === "string" ? { title: _props } : { ..._props };
              const icon = _icon ?? specStyle?.icon;
              const _id = b.__fqn(id);
              b.__addElement(exact({
                id: _id,
                kind,
                title: title ?? nameFromFqn(_id),
                ...description && { description: { txt: description } },
                ...summary && { summary: { txt: summary } },
                style: exact({
                  icon,
                  color: color ?? specStyle?.color,
                  shape: shape ?? specStyle?.shape,
                  border: specStyle?.border,
                  opacity: specStyle?.opacity,
                  size: specStyle?.size,
                  padding: specStyle?.padding,
                  textSize: specStyle?.textSize,
                  ...style
                }),
                links: mapLinks(links),
                ...spec2,
                ...props
              }));
              return b;
            });
            add.with = (...ops) => (b) => {
              add(b);
              const { __fqn, __addSourcelessRelation } = b;
              try {
                b.__fqn = (child) => `${__fqn(id)}.${child}`;
                b.__addSourcelessRelation = (relation) => {
                  return b.__addRelation({
                    ...relation,
                    source: {
                      model: __fqn(id)
                    }
                  });
                };
                ops.reduce((b2, op) => op(b2), b);
              } finally {
                b.__fqn = __fqn;
                b.__addSourcelessRelation = __addSourcelessRelation;
              }
              return b;
            };
            return add;
          }
        )
      },
      views: {
        views: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        view: (id, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            [_type]: "element",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        viewOf: (id, viewOf, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            viewOf,
            [_type]: "element",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        deploymentView: (id, _props, _builder) => {
          const [generic, builder2] = createGenericView(id, _props, _builder);
          const view = {
            ...generic,
            [_type]: "deployment",
            rules: []
          };
          const add = (b) => {
            b.__addView(view);
            if (builder2) {
              builder2(mkViewBuilder(view));
            }
            return b;
          };
          add.with = (...ops) => (b) => {
            add(b);
            const elementViewBuilder = mkViewBuilder(view);
            for (const op of ops) {
              op(elementViewBuilder);
            }
            return b;
          };
          return add;
        },
        $autoLayout,
        $exclude,
        $include,
        $rules,
        $style
      },
      deployment: {
        deployment: (...ops) => {
          return (b) => {
            return ops.reduce((b2, op) => op(b2), b);
          };
        },
        instanceOf: (id, target, _props) => {
          return (b) => {
            if (e$2(target)) {
              target = id;
              id = nameFromFqn(id);
            } else if (typeof target === "string") {
              _props ??= {};
            } else {
              _props = target;
              target = id;
              id = nameFromFqn(id);
            }
            const {
              links,
              title,
              description,
              summary,
              icon,
              color,
              shape,
              style,
              ...props
            } = typeof _props === "string" ? { title: _props } : { ..._props };
            const _id = b.__deploymentFqn(id);
            invariant(_elements.has(target), `Target element with id "${target}" not found`);
            b.__addDeployment(
              exact({
                id: _id,
                element: target,
                ...title && { title },
                ...summary && { summary: { txt: summary } },
                ...description && { description: { txt: description } },
                style: exact({
                  icon,
                  color,
                  shape,
                  ...style
                }),
                links: mapLinks(links),
                ...props
              })
            );
            return b;
          };
        },
        rel: (source, target, _props) => {
          return (b) => {
            const {
              title = null,
              links,
              description = null,
              ...props
            } = typeof _props === "string" ? { title: _props } : { ..._props };
            b.__addDeploymentRelation(exact({
              source: {
                deployment: source
              },
              target: {
                deployment: target
              },
              title,
              ...description && { description: { txt: description } },
              links: mapLinks(links),
              ...props
            }));
            return b;
          };
        },
        ...t$3(
          spec.deployments ?? {},
          ({ style: specStyle, ...spec2 }, kind) => (id, _props) => {
            const add = ((b) => {
              const {
                links,
                icon: _icon,
                style,
                title,
                description,
                summary,
                color,
                shape,
                ...props
              } = typeof _props === "string" ? { title: _props } : { ..._props };
              const icon = _icon ?? specStyle?.icon;
              const _id = b.__deploymentFqn(id);
              b.__addDeployment(
                exact({
                  id: _id,
                  kind,
                  title: title ?? nameFromFqn(_id),
                  ...description && { description: { txt: description } },
                  ...summary && { summary: { txt: summary } },
                  style: exact({
                    icon,
                    color: color ?? specStyle?.color,
                    shape: shape ?? specStyle?.shape,
                    border: specStyle?.border,
                    opacity: specStyle?.opacity,
                    size: specStyle?.size,
                    padding: specStyle?.padding,
                    textSize: specStyle?.textSize,
                    ...style
                  }),
                  links: mapLinks(links),
                  ...spec2,
                  ...props
                })
              );
              return b;
            });
            add.with = (...ops) => (b) => {
              add(b);
              const { __deploymentFqn } = b;
              try {
                b.__deploymentFqn = (child) => `${__deploymentFqn(id)}.${child}`;
                ops.reduce((b2, op) => op(b2), b);
              } finally {
                b.__deploymentFqn = __deploymentFqn;
              }
              return b;
            };
            return add;
          }
        )
      }
    }),
    with: (...ops) => {
      return ops.reduce((b, op) => op(b), self).clone();
    },
    model: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().model;
      const _ = helpers.model;
      return cb({ ...helpers, _ }, _)(b);
    },
    deployment: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().deployment;
      const _ = helpers.deployment;
      return cb({ ...helpers, _ }, _)(b);
    },
    views: (cb) => {
      const b = self.clone();
      const helpers = b.helpers().views;
      return cb({
        ...helpers,
        _: helpers.views
      }, helpers.views)(b);
    }
  };
  return self;
}
const Builder = {
  /**
   * Creates a builder with compositional methods
   *
   * @example
   * ```ts
   * const {
   *   model: { model, system, component, relTo },
   *   deployment: { env, vm},
   *   views: { view, $include },
   *   builder,
   * } = Builder.forSpecification({
   *   elements: {
   *     system: {},
   *     component: {},
   *   },
   *   deployments: ['env', 'vm'],
   * })
   *
   * const b = builder
   *   .with(
   *     model(
   *       system('cloud').with(
   *         component('backend'),
   *         component('backend.api'),
   *         component('frontend').with(
   *           relTo('cloud.backend.api'),
   *         ),
   *       ),
   *     ),
   *   )
   * ```
   */
  forSpecification(spec) {
    const b = builder(spec);
    return {
      ...b.helpers(),
      builder: b
    };
  },
  /**
   * Creates a builder with chainable methods
   *
   * @example
   * ```ts
   * const b = Builder
   *   .specification({
   *     elements: ['system', 'component'],
   *     deployments: ['env', 'vm'],
   *   })
   *   .model(({ system, component, relTo }, _) =>
   *     _(
   *       system('cloud').with(
   *         component('backend').with(
   *           component('api'),
   *         ),
   *         component('frontend').with(
   *           relTo('cloud.backend.api'),
   *         )
   *       )
   *     )
   *   )
   * ```
   */
  specification(spec) {
    return builder(spec);
  }
};

export { Builder };
