import { n as n$6, t as t$b, e as e$4, a as DeploymentNodeModel, b as DeployedInstanceModel, c as DeploymentRelationModel, N as NestedElementOfDeployedInstanceModel } from './core.CHwVhuc9.mjs';
import { e as e$3 } from './core.BKlholso.mjs';
import { c as splitGlobalFqn, g as extractStep, e as isStepEdgeId, i as isGroupElementKind, b as isGlobalFqn, a as GlobalFqn } from './core.C_Ni6yHl.mjs';
import { m as hierarchyLevel, n as nameFromFqn, i as isAncestor, g as commonAncestor, s as sortNaturalByFqn, f as sortParentsFirst, p as parentFqn, a as ancestorsFqn } from './core.6VsRBhGY.mjs';
import { m as memoizeProp } from './core.BR4zXDH-.mjs';
import { R as RichText, e as exact } from './core.M9ayqQZa.mjs';
import { preferSummary, preferDescription } from '../types/_aux.mjs';
import { i as ihead } from './core.uFk_o9X6.mjs';
import { a as t$9, t as t$a } from './core.OHD4KXm9.mjs';
import { t as t$8, a as t$c } from './core.BsSXS-_R.mjs';
import { e as e$5, t as t$d, a as t$g } from './core.B9BjmjuH.mjs';
import { t as t$e } from './core.CbT8JVYL.mjs';
import { a as t$f, L as LikeC4Styles } from './core.DEieYfbG.mjs';
import { g as getOrCreate } from './core.DcS-0zys.mjs';
import { D as DefaultMap } from './core.BbE4y-yl.mjs';
import { i as invariant, a as nonNullable } from './core.D4npX2q8.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { c as isDeploymentNode, b as _layout, u as e$6, t as isDynamicView, a as _type, _ as _stage, i as isOnStage, w as whereOperatorAsPredicate } from './core.DH7TXqXf.mjs';
import { s as symmetricDifference } from './core.CbsSAn1j.mjs';
import { i as ifind } from './core.CmPXpJ8l.mjs';
import { i as ifilter } from './core.DRJma0Ol.mjs';
import { a as compareNaturalHierarchically, c as compareNatural } from './core.Bv3cd-jC.mjs';
import './core.C0Ye2OCr.mjs';
import './core.bKIs4oDO.mjs';

const e$2={asc:(e,t)=>e>t,desc:(e,t)=>e<t};function t$7(e,t){let[n,...a]=t;if(!i$1(n)){let t=r$2(...a);return e(n,t)}let o=r$2(n,...a);return t=>e(t,o)}function r$2(t,n,...i){let a=typeof t==`function`?t:t[0],o=typeof t==`function`?`asc`:t[1],{[o]:s}=e$2,c=n===void 0?void 0:r$2(n,...i);return (e,t)=>{let n=a(e),r=a(t);return s(n,r)?1:s(r,n)?-1:c?.(e,t)??0}}function i$1(t){if(a(t))return  true;if(typeof t!=`object`||!Array.isArray(t))return  false;let[n,r,...i]=t;return a(n)&&typeof r==`string`&&r in e$2&&i.length===0}const a=e=>typeof e==`function`&&e.length===1;

function n$5(...t){return t$8(r$1,t,i)}const r$1=(e,t)=>e.filter(t),i=e=>(n,r,i)=>e(n,r,i)?{done:false,hasNext:true,next:n}:t$9;

function t$6(...t){return t$8(n$4,t,r)}const n$4=(e,t)=>e.flatMap(t),r=e=>(t,n,r)=>{let i=e(t,n,r);return Array.isArray(i)?{done:false,hasNext:true,hasMany:true,next:i}:{done:false,hasNext:true,next:i}};

function t$5(...t){return t$8(n$3,t)}const n$3=(e,t)=>{let n=Object.create(null);for(let r=0;r<e.length;r++){let i=e[r],a=t(i,r,e);if(a!==void 0){let e=n[a];e===void 0?n[a]=[i]:e.push(i);}}return Object.setPrototypeOf(n,Object.prototype),n};

function e$1(e){return typeof e==`number`&&!Number.isNaN(e)}

function t$4(...t){return t$8(n$2,t)}const n$2=e=>e.at(-1);

function t$3(...t){return t$8(n$1,t)}function n$1(e,t){let n={};for(let[r,i]of Object.entries(e))n[r]=t(i,r,e);return n}

function t$2(...t){return n=>t$a(n,...t)}

function t$1(...t){return t$7(n,t)}const n=(e,t)=>[...e].sort(t);

function e(e,t,n){return typeof t==`number`||t===void 0?n=>n.split(e,t):e.split(t,n)}

function t(...t){return t$8(Object.values,t)}

class ElementModel {
  constructor($model, $element) {
    this.$model = $model;
    this.$element = $element;
    this.id = this.$element.id;
    this._literalId = this.$element.id;
    const [projectId, fqn] = splitGlobalFqn(this.id);
    if (projectId) {
      this.imported = {
        from: projectId,
        fqn
      };
      this.hierarchyLevel = hierarchyLevel(fqn);
    } else {
      this.imported = null;
      this.hierarchyLevel = hierarchyLevel(this.id);
    }
  }
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  id;
  _literalId;
  hierarchyLevel;
  imported;
  get name() {
    return nameFromFqn(this.id);
  }
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$element.kind;
  }
  get shape() {
    return this.style.shape;
  }
  get color() {
    return this.style.color;
  }
  get icon() {
    return this.style.icon ?? null;
  }
  /**
   * Returns all tags of the element.
   * It includes tags from the element and its kind.
   */
  get tags() {
    return memoizeProp(this, Symbol.for("tags"), () => {
      return n$6([
        ...this.$element.tags ?? [],
        ...this.$model.specification.elements[this.$element.kind]?.tags ?? []
      ]);
    });
  }
  get title() {
    return this.$element.title;
  }
  /**
   * Returns true if the element has a summary and a description
   * (if one is missing - it falls back to another)
   */
  get hasSummary() {
    return !!this.$element.summary && !!this.$element.description && !t$b(this.$element.summary, this.$element.description);
  }
  /**
   * Short description of the element.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$element));
  }
  /**
   * Long description of the element.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$element));
  }
  get technology() {
    return this.$element.technology ?? null;
  }
  get links() {
    return this.$element.links ?? [];
  }
  get defaultView() {
    return memoizeProp(this, Symbol.for("defaultView"), () => ihead(this.scopedViews()) ?? null);
  }
  get isRoot() {
    return this.parent === null;
  }
  get style() {
    return memoizeProp(this, "style", () => exact({
      shape: this.$model.$styles.defaults.shape,
      color: this.$model.$styles.defaults.color,
      border: this.$model.$styles.defaults.border,
      opacity: this.$model.$styles.defaults.opacity,
      size: this.$model.$styles.defaults.size,
      padding: this.$model.$styles.defaults.padding,
      textSize: this.$model.$styles.defaults.text,
      ...this.$element.style
    }));
  }
  isAncestorOf(another) {
    return isAncestor(this, another);
  }
  isDescendantOf(another) {
    return isAncestor(another, this);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.element(common) : null;
  }
  children() {
    return this.$model.children(this);
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  descendants(sort) {
    if (sort) {
      const sorted = sortNaturalByFqn([...this.$model.descendants(this)], sort);
      return sorted[Symbol.iterator]();
    }
    return this.$model.descendants(this);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Resolve siblings of the element and its ancestors
   * (from closest parent to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  *incomers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique2.has(r.source.id)) {
        continue;
      }
      unique2.add(r.source.id);
      yield r.source;
    }
    return;
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *outgoers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique2.has(r.target.id)) {
        continue;
      }
      unique2.add(r.target.id);
      yield r.target;
    }
    return;
  }
  get allOutgoing() {
    return memoizeProp(this, Symbol.for("allOutgoing"), () => new Set(this.outgoing()));
  }
  get allIncoming() {
    return memoizeProp(this, Symbol.for("allIncoming"), () => new Set(this.incoming()));
  }
  /**
   * Iterate over all views that include this element.
   */
  views() {
    return memoizeProp(this, Symbol.for("views"), () => {
      const views = /* @__PURE__ */ new Set();
      for (const view of this.$model.views()) {
        if (view.includesElement(this.id)) {
          views.add(view);
        }
      }
      return views;
    });
  }
  /**
   * Iterate over all views that scope this element.
   * It is possible that element is not included in the view.
   */
  scopedViews() {
    return memoizeProp(this, Symbol.for("scopedViews"), () => {
      const views = /* @__PURE__ */ new Set();
      for (const vm of this.$model.views()) {
        if (vm.isScopedElementView() && vm.viewOf.id === this.id) {
          views.add(vm);
        }
      }
      return views;
    });
  }
  /**
   * @returns true if the element is deployed
   */
  isDeployed() {
    return e$3(ihead(this.deployments()));
  }
  deployments() {
    return this.$model.deployment.instancesOf(this);
  }
  hasMetadata() {
    return !!this.$element.metadata && !e$4(this.$element.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$element.metadata?.[field];
    }
    return this.$element.metadata ?? {};
  }
  /**
   * Checks if the element has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

const getId = (element) => {
  return typeof element === "string" ? element : element.id;
};

const VIEW_FOLDERS_SEPARATOR = "/";
const splitViewTitle = (title) => {
  invariant(!title.includes("\n"), "View title cannot contain newlines");
  if (title.includes(VIEW_FOLDERS_SEPARATOR)) {
    const segments = title.split(VIEW_FOLDERS_SEPARATOR).map((s) => s.trim()).filter((s) => s.length > 0);
    if (t$c(segments, 1)) {
      return segments;
    }
    return [""];
  }
  return [title.trim()];
};
const normalizeViewPath = (title) => {
  return splitViewTitle(title).join(VIEW_FOLDERS_SEPARATOR);
};
const getViewFolderPath = (title) => {
  const segments = splitViewTitle(title);
  if (!t$c(segments, 2)) {
    return null;
  }
  return segments.slice(0, -1).join(VIEW_FOLDERS_SEPARATOR);
};
const extractViewTitleFromPath = (title) => {
  if (!title.includes(VIEW_FOLDERS_SEPARATOR)) {
    return title.trim();
  }
  return splitViewTitle(title).pop() ?? title;
};

class LikeC4DeploymentModel {
  constructor($model) {
    this.$model = $model;
    const $deployments = this.$deployments = $model.$data.deployments;
    const elements = t($deployments.elements);
    for (const element of sortParentsFirst(elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
      if (el.isInstance()) {
        this.#instancesOf.get(el.element.id).add(el);
      }
    }
    for (const relation of t($deployments.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
  }
  #elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  #parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  #children = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Keep track of instances of the logical element
  #instancesOf = new DefaultMap(() => /* @__PURE__ */ new Set());
  #rootElements = /* @__PURE__ */ new Set();
  #relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  #incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  #outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  #internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  // readonly #views = new Map<ViewID, LikeC4ViewModel<A>>()
  #allTags = new DefaultMap(
    () => /* @__PURE__ */ new Set()
  );
  #nestedElementsOfDeployment = /* @__PURE__ */ new Map();
  $deployments;
  get $styles() {
    return this.$model.$styles;
  }
  element(el) {
    if (el instanceof DeploymentNodeModel || el instanceof DeployedInstanceModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this.#elements.get(id), `Element ${id} not found`);
  }
  findElement(el) {
    return this.#elements.get(el) ?? null;
  }
  node(el) {
    const element = this.element(el);
    invariant(element.isDeploymentNode(), `Element ${element.id} is not a deployment node`);
    return element;
  }
  findNode(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isDeploymentNode(), `Element ${element?.id} is not a deployment node`);
    return element;
  }
  instance(el) {
    const element = this.element(el);
    invariant(element.isInstance(), `Element ${element.id} is not a deployed instance`);
    return element;
  }
  findInstance(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isInstance(), `Element ${element?.id} is not a deployed instance`);
    return element;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this.#rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this.#elements.values();
  }
  /**
   * Returns all elements in the model.
   */
  *nodes() {
    for (const element of this.#elements.values()) {
      if (element.isDeploymentNode()) {
        yield element;
      }
    }
    return;
  }
  *nodesOfKind(kind) {
    for (const node of this.#elements.values()) {
      if (node.isDeploymentNode() && node.kind === kind) {
        yield node;
      }
    }
    return;
  }
  *instances() {
    for (const element of this.#elements.values()) {
      if (element.isInstance()) {
        yield element;
      }
    }
    return;
  }
  /**
   * Iterate over all instances of the given logical element.
   */
  *instancesOf(element) {
    const id = getId(element);
    const instances = this.#instancesOf.get(id);
    if (instances) {
      yield* instances;
    }
    return;
  }
  deploymentRef(ref) {
    if (FqnRef.isInsideInstanceRef(ref)) {
      const { deployment, element } = ref;
      return getOrCreate(this.#nestedElementsOfDeployment, `${deployment}@${element}`, () => {
        return new NestedElementOfDeployedInstanceModel(this.instance(deployment), this.$model.element(element));
      });
    }
    return this.element(ref.deployment);
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this.#relations.values();
  }
  /**
   * Returns a specific relationship by its ID.
   */
  relationship(id) {
    return nonNullable(this.#relations.get(getId(id)), `DeploymentRelationModel ${id} not found`);
  }
  findRelationship(id) {
    return this.#relations.get(id) ?? null;
  }
  /**
   * Returns all deployment views in the model.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.isDeploymentView()) {
        yield view;
      }
    }
    return;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this.#parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this.#children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const siblings = this.parent(element)?.children() ?? this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = this.#parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element, sort = "desc") {
    for (const child of this.children(element)) {
      if (sort === "asc") {
        yield child;
        yield* this.descendants(child.id);
      } else {
        yield* this.descendants(child.id);
        yield child;
      }
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  addElement(element) {
    if (this.#elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = isDeploymentNode(element) ? new DeploymentNodeModel(this, Object.freeze(element)) : new DeployedInstanceModel(this, Object.freeze(element), this.$model.element(element.element));
    this.#elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this.#elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this.#parents.set(el.id, this.node(parentId));
      this.#children.get(parentId).add(el);
    } else {
      invariant(el.isDeploymentNode(), `Root element ${el.id} is not a deployment node`);
      this.#rootElements.add(el);
    }
    return el;
  }
  addRelation(relation) {
    if (this.#relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new DeploymentRelationModel(
      this,
      Object.freeze(relation)
    );
    this.#relations.set(rel.id, rel);
    this.#incoming.get(rel.target.id).add(rel);
    this.#outgoing.get(rel.source.id).add(rel);
    const relParent = rel.boundary?.id ?? null;
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this.#internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(rel.source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this.#outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(rel.target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      this.#incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}

class RelationshipModel {
  constructor(model, $relationship) {
    this.model = model;
    this.$relationship = $relationship;
    this.source = model.element(FqnRef.flatten($relationship.source));
    this.target = model.element(FqnRef.flatten($relationship.target));
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.model.element(parent) : null;
  }
  source;
  target;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the Relation.
   */
  boundary;
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (!e$3(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (!e$3(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  /**
   * Returns true if the relationship has a summary and a description
   * (if one is missing - it falls back to another)
   */
  get hasSummary() {
    return !!this.$relationship.summary && !!this.$relationship.description && !t$b(this.$relationship.summary, this.$relationship.description);
  }
  /**
   * Short description of the relationship.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$relationship));
  }
  /**
   * Long description of the relationship.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$relationship));
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.model.view(this.$relationship.navigateTo) : null;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? this.model.$styles.defaults.relationship.color;
  }
  get line() {
    return this.$relationship.line ?? this.model.$styles.defaults.relationship.line;
  }
  get head() {
    return this.$relationship.head ?? this.model.$styles.defaults.relationship.arrow;
  }
  get tail() {
    return this.$relationship.tail;
  }
  /**
   * Iterate over all views that include this relationship.
   */
  *views() {
    for (const view of this.model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return false;
  }
  isModelRelation() {
    return true;
  }
  hasMetadata() {
    return !!this.$relationship.metadata && !e$4(this.$relationship.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$relationship.metadata?.[field];
    }
    return this.$relationship.metadata ?? {};
  }
  /**
   * Checks if the relationship has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

// src/utils/env.ts
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");

// src/utils/errors.ts
var errors = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (process.env.NODE_ENV !== "production") {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}

// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null || proto === Object.prototype)
    return true;
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  if (typeof Ctor !== "function")
    return false;
  let ctorString = cachedCtorStrings.get(Ctor);
  if (ctorString === void 0) {
    ctorString = Function.toString.call(Ctor);
    cachedCtorStrings.set(Ctor, ctorString);
  }
  return ctorString === objectCtorString;
}
function each(obj, iter, strict = true) {
  if (getArchtype(obj) === 0 /* Object */) {
    const keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
    keys.forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2 /* Map */)
    thing.set(propOrOldValue, value);
  else if (t === 3 /* Set */) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: dontMutateMethodOverride,
      add: dontMutateMethodOverride,
      clear: dontMutateMethodOverride,
      delete: dontMutateMethodOverride
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  value: dontMutateFrozenCollections
};
function isFrozen(obj) {
  if (obj === null || typeof obj !== "object")
    return true;
  return Object.isFrozen(obj);
}

// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}

// src/core/scope.ts
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)
    state.revoke_();
  else
    state.revoked_ = true;
}

// src/core/finalize.ts
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path),
      useStrictIteration
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3 /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(
        rootScope,
        state,
        result,
        key,
        childValue,
        path,
        isSet2
      ),
      useStrictIteration
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue == null) {
    return;
  }
  if (typeof childValue !== "object" && !targetIsSet) {
    return;
  }
  const childIsFrozen = isFrozen(childValue);
  if (childIsFrozen && !targetIsSet) {
    return;
  }
  if (process.env.NODE_ENV !== "production" && childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !childIsFrozen) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

// src/core/proxy.ts
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 /* Array */ : 0 /* Object */,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}

// src/core/immerClass.ts
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.useStrictIteration_ = true;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
    if (typeof config?.useStrictIteration === "boolean")
      this.setUseStrictIteration(config.useStrictIteration);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}

// src/core/current.ts
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  let strict = true;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    strict = state.scope_.immer_.shouldUseStrictIteration();
  } else {
    copy = shallowCopy(value, true);
  }
  each(
    copy,
    (key, childValue) => {
      set(copy, key, currentImpl(childValue));
    },
    strict
  );
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}

// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;

function buildElementNotations(nodes) {
  return t$a(
    nodes,
    n$5((n) => !!n.notation),
    t$5(e$5("notation")),
    t$3(
      t$2(
        t$5(e$5("shape")),
        t$3(
          t$2(
            t$5(e$5("color")),
            t$3(
              t$2(
                t$e(e$5("kind")),
                n$6()
              )
            ),
            t$d(),
            t$e(([color, kinds]) => ({
              kinds,
              color
            }))
          )
        ),
        t$d(),
        t$6(
          ([shape, colors]) => colors.map(({ color, kinds }) => ({
            shape,
            color,
            kinds
          }))
        )
      )
    ),
    t$d(),
    t$6(
      ([title, shapes]) => shapes.map(({ shape, color, kinds }) => ({
        title,
        shape,
        color,
        kinds
      }))
    ),
    t$1(
      e$5("shape"),
      e$5("title"),
      [
        (n) => n.kinds.length,
        "desc"
      ]
    )
  );
}

const changed = (a, b) => {
  if (a === b || e$6(a) && e$6(b)) {
    return false;
  }
  return !t$f(a, b);
};
const MAX_ALLOWED_DRIFT = 5;
function autoApplyMetaAndStyles(draft, next) {
  draft.color = next.color;
  draft.kind = next.kind;
  draft.navigateTo = next.navigateTo ?? null;
  draft.links = next.links ? [...next.links] : null;
  draft.tags = [...next.tags];
  if (e$6(next.style.border)) {
    delete draft.style.border;
  } else {
    draft.style.border = next.style.border;
  }
  if (e$1(next.style.opacity)) {
    draft.style.opacity = next.style.opacity;
  } else {
    delete draft.style.opacity;
  }
  if (e$6(next.style.multiple)) {
    delete draft.style.multiple;
  } else {
    draft.style.multiple = next.style.multiple;
  }
}
function autoApplyIcon(draft, next, sizeNotChanged) {
  if (changed(next.icon ?? "none", draft.icon ?? "none")) {
    const iconWasSet = e$3(draft.icon) && draft.icon !== "none";
    switch (true) {
      // Icon was set before and changed, auto-apply
      case (iconWasSet && e$3(next.icon) && next.icon !== "none"): {
        draft.icon = next.icon;
        return true;
      }
      // Icon was set before and now removed, auto-apply
      case (iconWasSet && (e$6(next.icon) || next.icon === "none")): {
        draft.icon = "none";
        return true;
      }
      // Icon was added
      case (!iconWasSet && e$3(next.icon) && next.icon !== "none"): {
        if (sizeNotChanged) {
          draft.icon = next.icon;
          return true;
        } else {
          return false;
        }
      }
    }
  }
  return true;
}
function autoApplyLabelsToLeaf(draft, next, sizeNotChanged) {
  let applied = true;
  if (changed(draft.title, next.title)) {
    if (sizeNotChanged) {
      draft.title = next.title;
    } else {
      applied = false;
    }
  }
  if (changed(draft.description, next.description)) {
    if (e$6(next.description)) {
      delete draft.description;
    } else if (sizeNotChanged) {
      draft.description = next.description;
    } else {
      applied = false;
    }
  }
  if (changed(draft.technology, next.technology)) {
    if (e$6(next.technology)) {
      delete draft.technology;
    } else if (sizeNotChanged) {
      draft.technology = next.technology;
    } else {
      applied = false;
    }
  }
  return applied;
}
function autoApplyLabelsToCompound(draft, next, _sizeNotChanged) {
  draft.title = next.title;
  if (e$6(next.description)) {
    delete draft.description;
  } else {
    draft.description = next.description;
  }
  if (e$6(next.technology)) {
    delete draft.technology;
  } else {
    draft.technology = next.technology;
  }
  return true;
}
function applyManualLayout(autoLayouted, snapshot) {
  invariant(autoLayouted.id === snapshot.id, "applyManualLayout: view ids do not match");
  invariant(autoLayouted._stage === "layouted", "applyManualLayout: expected layouted view");
  invariant(snapshot._stage === "layouted", "applyManualLayout: expected layouted snapshot");
  invariant(autoLayouted._layout !== "manual", "applyManualLayout: expected auto-layouted view");
  const viewDrifts = /* @__PURE__ */ new Set();
  if (autoLayouted._type !== snapshot._type) {
    viewDrifts.add("type-changed");
  }
  const nextNodes = new Map(autoLayouted.nodes.map((n) => [n.id, n]));
  const nextEdges = new Map(autoLayouted.edges.map((e) => [e.id, e]));
  const nextNodeIds = new Set(nextNodes.keys());
  const nextEdgeIds = new Set(nextEdges.keys());
  const snapshotNodeIds = new Set(snapshot.nodes.map((n) => n.id));
  const snapshotEdgeIds = new Set(snapshot.edges.map((e) => e.id));
  if (symmetricDifference(nextNodeIds, snapshotNodeIds).size > 0) {
    viewDrifts.add("nodes-mismatch");
  }
  if (symmetricDifference(nextEdgeIds, snapshotEdgeIds).size > 0) {
    viewDrifts.add("edges-mismatch");
  }
  const nodes = snapshot.nodes.map((node) => {
    const next = nextNodes.get(node.id);
    return produce(node, (draft) => {
      if (!next) {
        draft.drifts = ["missing"];
        return;
      }
      autoApplyMetaAndStyles(draft, next);
      const nodeDrifts = /* @__PURE__ */ new Set();
      const wasCompound = node.children.length > 0;
      const willBeCompound = next.children.length > 0;
      if (changed(draft.modelRef, next.modelRef) || changed(draft.deploymentRef, next.deploymentRef)) {
        nodeDrifts.add("modelRef-changed");
      }
      if (willBeCompound && !wasCompound) {
        nodeDrifts.add("became-compound");
      }
      if (!willBeCompound && wasCompound) {
        nodeDrifts.add("became-leaf");
      }
      if (changed(draft.parent, next.parent)) {
        nodeDrifts.add("parent-changed");
      }
      const sizeNotChanged = draft.width + MAX_ALLOWED_DRIFT >= next.width && draft.height + MAX_ALLOWED_DRIFT >= next.height;
      if (changed(draft.shape, next.shape)) {
        if (sizeNotChanged) {
          draft.shape = next.shape;
        } else {
          nodeDrifts.add("shape-changed");
        }
      }
      if (!autoApplyIcon(draft, next, sizeNotChanged && willBeCompound === wasCompound)) {
        nodeDrifts.add("label-changed");
      }
      const autoApplyLabels = wasCompound ? autoApplyLabelsToCompound : autoApplyLabelsToLeaf;
      if (!autoApplyLabels(draft, next, sizeNotChanged)) {
        nodeDrifts.add("label-changed");
      }
      if (changed(node.notation, next.notation)) {
        draft.notation = next.notation ?? null;
      }
      if (wasCompound && willBeCompound && symmetricDifference(new Set(node.children), new Set(next.children)).size > 0) {
        nodeDrifts.add("children-changed");
      }
      const _drifts = [...nodeDrifts];
      if (t$c(_drifts, 1)) {
        viewDrifts.add("nodes-mismatch");
        draft.drifts = _drifts;
      }
    });
  });
  const edges = snapshot.edges.map((edge) => {
    const next = nextEdges.get(edge.id);
    return produce(edge, (draft) => {
      if (!next) {
        draft.drifts = ["missing"];
        return;
      }
      const edgeDrifts = /* @__PURE__ */ new Set();
      if (draft.source === next.target && draft.target === next.source) {
        edgeDrifts.add("direction-changed");
      } else {
        if (draft.source !== next.source) {
          edgeDrifts.add("source-changed");
        }
        if (draft.target !== next.target) {
          edgeDrifts.add("target-changed");
        }
      }
      if (edgeDrifts.size === 0 && changed(draft.dir ?? "forward", next.dir ?? "forward")) {
        edgeDrifts.add("direction-changed");
      }
      draft.color = next.color;
      draft.line = next.line;
      draft.navigateTo = next.navigateTo ?? null;
      draft.tags = next.tags ? [...next.tags] : null;
      if (e$6(next.notes)) {
        delete draft.notes;
      } else {
        draft.notes = next.notes;
      }
      if (next.astPath) {
        draft.astPath = next.astPath;
      }
      if (next.labelBBox) {
        if (!draft.labelBBox || !e$3(draft.label) && e$3(next.label)) {
          edgeDrifts.add("label-changed");
        }
        draft.labelBBox = {
          // Preserve x,y if possible
          x: draft.labelBBox?.x ?? next.labelBBox.x,
          y: draft.labelBBox?.y ?? next.labelBBox.y,
          // Take width/height from next
          width: next.labelBBox.width,
          height: next.labelBBox.height
        };
        draft.label = next.label;
        draft.description = next.description ?? null;
        draft.technology = next.technology ?? null;
      } else if (edge.labelBBox) {
        edgeDrifts.add("label-changed");
      }
      const _drifts = [...edgeDrifts];
      if (t$c(_drifts, 1)) {
        viewDrifts.add("edges-mismatch");
        draft.drifts = _drifts;
      }
    });
  });
  const nodeNotations = buildElementNotations(nodes);
  const result = { ...snapshot };
  Object.assign(
    result,
    {
      // Auto-layouted properties
      title: autoLayouted.title ?? snapshot.title,
      description: autoLayouted.description ?? snapshot.description,
      tags: autoLayouted.tags ? [...autoLayouted.tags] : null,
      links: autoLayouted.links ? [...autoLayouted.links] : null,
      [_layout]: "manual",
      ...nodeNotations && nodeNotations.length > 0 ? { notation: { nodes: nodeNotations } } : {},
      nodes,
      edges
    }
  );
  if (isDynamicView(autoLayouted) && result._type === "dynamic") {
    Object.assign(
      result,
      {
        variant: autoLayouted.variant
      }
    );
  }
  const drifts = [...viewDrifts];
  if (t$c(drifts, 1)) {
    result.drifts = drifts;
  } else {
    if ("drifts" in result) {
      delete result.drifts;
    }
  }
  return result;
}
function applyLayoutDriftReasons(autoLayouted, snapshot) {
  const { drifts } = applyManualLayout(autoLayouted, snapshot);
  if (drifts) {
    Object.assign(
      autoLayouted,
      {
        [_layout]: "auto",
        drifts
      }
    );
  } else {
    const mutable = autoLayouted;
    if ("drifts" in autoLayouted) {
      delete mutable.drifts;
    }
  }
  return autoLayouted;
}

class EdgeModel {
  constructor($viewModel, $edge, source, target) {
    this.source = source;
    this.target = target;
    this.$viewModel = $viewModel;
    this.$view = $viewModel.$view;
    this.$edge = $edge;
  }
  Aux;
  $viewModel;
  $view;
  $edge;
  get id() {
    return this.$edge.id;
  }
  get parent() {
    return this.$edge.parent ? this.$viewModel.node(this.$edge.parent) : null;
  }
  get label() {
    return this.$edge.label ?? null;
  }
  get description() {
    return RichText.memoize(this, "description", this.$edge.description);
  }
  get technology() {
    return this.$edge.technology ?? null;
  }
  hasParent() {
    return this.$edge.parent !== null;
  }
  get tags() {
    return this.$edge.tags ?? [];
  }
  get stepNumber() {
    return this.isStep() ? extractStep(this.id) : null;
  }
  get navigateTo() {
    return this.$edge.navigateTo ? this.$viewModel.$model.view(this.$edge.navigateTo) : null;
  }
  get color() {
    return this.$edge.color;
  }
  get line() {
    return this.$edge.line ?? this.$viewModel.$styles.defaults.relationship.line;
  }
  get head() {
    return this.$edge.head ?? this.$viewModel.$styles.defaults.relationship.arrow;
  }
  get tail() {
    return this.$edge.tail;
  }
  isStep() {
    return isStepEdgeId(this.id);
  }
  *relationships(type) {
    for (const id of this.$edge.relations) {
      if (type) {
        const rel = this.$viewModel.$model.findRelationship(id, type);
        if (rel) {
          yield rel;
        }
      } else {
        yield this.$viewModel.$model.relationship(id);
      }
    }
    return;
  }
  includesRelation(rel) {
    const id = typeof rel === "string" ? rel : rel.id;
    return this.$edge.relations.includes(id);
  }
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

class NodeModel {
  Aux;
  $viewModel;
  $view;
  $node;
  constructor($viewModel, $node) {
    this.$viewModel = $viewModel;
    this.$view = $viewModel.$view;
    this.$node = $node;
  }
  get id() {
    return this.$node.id;
  }
  get title() {
    return this.$node.title;
  }
  get kind() {
    return this.$node.kind;
  }
  get description() {
    return RichText.memoize(this, "description", this.$node.description);
  }
  get technology() {
    return this.$node.technology ?? null;
  }
  get parent() {
    return this.$node.parent ? this.$viewModel.node(this.$node.parent) : null;
  }
  get element() {
    const modelRef = this.$node.modelRef;
    return modelRef ? this.$viewModel.$model.element(modelRef) : null;
  }
  get deployment() {
    const modelRef = this.$node.deploymentRef;
    return modelRef ? this.$viewModel.$model.deployment.element(modelRef) : null;
  }
  get shape() {
    return this.$node.shape;
  }
  get color() {
    return this.$node.color;
  }
  get icon() {
    return this.$node.icon ?? null;
  }
  get tags() {
    return this.$node.tags;
  }
  get links() {
    return this.$node.links ?? [];
  }
  get navigateTo() {
    return this.$node.navigateTo ? this.$viewModel.$model.view(this.$node.navigateTo) : null;
  }
  get style() {
    return this.$node.style;
  }
  get x() {
    return "x" in this.$node ? this.$node.x : void 0;
  }
  get y() {
    return "y" in this.$node ? this.$node.y : void 0;
  }
  get width() {
    return "width" in this.$node ? this.$node.width : void 0;
  }
  get height() {
    return "height" in this.$node ? this.$node.height : void 0;
  }
  children() {
    return memoizeProp(this, "children", () => new Set(this.$node.children.map((child) => this.$viewModel.node(child))));
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors() {
    let parent = this.parent;
    while (parent) {
      yield parent;
      parent = parent.parent;
    }
    return;
  }
  *siblings() {
    const siblings = this.parent?.children() ?? this.$viewModel.roots();
    for (const sibling of siblings) {
      if (sibling.id !== this.id) {
        yield sibling;
      }
    }
    return;
  }
  *incoming(filter = "all") {
    for (const edgeId of this.$node.inEdges) {
      const edge = this.$viewModel.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.target.id === this.id):
        case (filter === "to-descendants" && edge.target.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique.has(r.source.id)) {
        continue;
      }
      unique.add(r.source.id);
      yield r.source;
    }
    return;
  }
  *outgoing(filter = "all") {
    for (const edgeId of this.$node.outEdges) {
      const edge = this.$viewModel.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.source.id === this.id):
        case (filter === "from-descendants" && edge.source.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique.has(r.target.id)) {
        continue;
      }
      unique.add(r.target.id);
      yield r.target;
    }
    return;
  }
  isLayouted() {
    return "width" in this.$node && "height" in this.$node;
  }
  hasChildren() {
    return this.$node.children.length > 0;
  }
  hasParent() {
    return this.$node.parent !== null;
  }
  /**
   * Check if this node references to logical model element.
   */
  hasElement() {
    return e$3(this.$node.modelRef);
  }
  /**
   * Check if this node references to deployment element (Node or Instance).
   */
  hasDeployment() {
    return e$3(this.$node.deploymentRef);
  }
  /**
   * Check if this node references to deployed instance
   * Deployed instance always references to element and deployment element.
   */
  hasDeployedInstance() {
    return this.hasElement() && this.hasDeployment();
  }
  isGroup() {
    return isGroupElementKind(this.$node);
  }
  /**
   * Checks if the node has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

class LikeC4ViewModel {
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  #view;
  #rootnodes = /* @__PURE__ */ new Set();
  #nodes = /* @__PURE__ */ new Map();
  #edges = /* @__PURE__ */ new Map();
  #includeElements = /* @__PURE__ */ new Set();
  #includeDeployments = /* @__PURE__ */ new Set();
  #includeRelations = /* @__PURE__ */ new Set();
  #allTags = new DefaultMap((_key) => /* @__PURE__ */ new Set());
  #manualLayoutSnapshot;
  id;
  /**
   * The model this view belongs to
   */
  $model;
  /**
   * The title of the view
   */
  title;
  /**
   * View folder this view belongs to.
   * If view is top-level, this is the root folder.
   */
  folder;
  /**
   * Path to this view, processed by {@link normalizeViewPath}
   *
   * @example
   * "Group 1/Group 2/View"
   */
  viewPath;
  constructor(model, folder, view, manualLayoutSnapshot) {
    this.$model = model;
    this.#view = view;
    this.id = view.id;
    this.folder = folder;
    this.#manualLayoutSnapshot = manualLayoutSnapshot;
    for (const node of this.#view.nodes) {
      const el = new NodeModel(this, Object.freeze(node));
      this.#nodes.set(node.id, el);
      if (!node.parent) {
        this.#rootnodes.add(el);
      }
      if (node.deploymentRef) {
        this.#includeDeployments.add(node.deploymentRef);
      }
      if (node.modelRef) {
        this.#includeElements.add(node.modelRef);
      }
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
    for (const edge of this.#view.edges) {
      const edgeModel = new EdgeModel(
        this,
        Object.freeze(edge),
        this.node(edge.source),
        this.node(edge.target)
      );
      for (const tag of edgeModel.tags) {
        this.#allTags.get(tag).add(edgeModel);
      }
      for (const rel of edge.relations) {
        this.#includeRelations.add(rel);
      }
      this.#edges.set(edge.id, edgeModel);
    }
    this.title = view.title ? extractViewTitleFromPath(view.title) : null;
    this.viewPath = view.title ? normalizeViewPath(view.title) : view.id;
  }
  /**
   * Returns the styles configuration for the project.
   */
  get $styles() {
    return this.$model.$styles;
  }
  get _type() {
    return this.#view[_type];
  }
  get stage() {
    return this.#view[_stage];
  }
  get bounds() {
    if ("bounds" in this.#view) {
      return this.#view.bounds;
    }
    if (this.#manualLayoutSnapshot) {
      return this.#manualLayoutSnapshot.bounds;
    }
    throw new Error("View is not layouted");
  }
  /**
   * Returns title if defined, otherwise returns title of the element it is based on, otherwise returns its {@link id}
   */
  get titleOrId() {
    return this.title ?? this.viewOf?.title ?? this.id;
  }
  /**
   * Returns title if defined, otherwise returns `Untitled`.
   */
  get titleOrUntitled() {
    return this.title ?? "Untitled";
  }
  /**
   * Returns path to this view as an array of groups and this view as the last element
   * If view is top-level, returns only this view.
   *
   * @example
   * viewPath = "Group 1/Group 2/View"
   *
   * breadcrumbs = [
   *   "Group 1",             // folder
   *   "Group 1/Group 2",     // folder
   *   "Group 1/Group 2/View" // view
   * ]
   */
  get breadcrumbs() {
    return memoizeProp(this, "breadcrumbs", () => {
      if (!this.folder.isRoot) {
        return [...this.folder.breadcrumbs, this];
      }
      return [this];
    });
  }
  get description() {
    return RichText.memoize(this, "description", this.#view.description);
  }
  get tags() {
    return this.#view.tags ?? [];
  }
  get links() {
    return this.#view.links ?? [];
  }
  get viewOf() {
    if (this.isElementView()) {
      const viewOf = this.#view.viewOf;
      return viewOf ? this.$model.element(viewOf) : null;
    }
    return null;
  }
  /**
   * Available for dynamic views only
   * throws error if view is not dynamic
   */
  get mode() {
    if (this.isDynamicView()) {
      return this.#view.variant ?? "diagram";
    }
    return null;
  }
  /**
   * All tags from nodes and edges.
   */
  get includedTags() {
    return [...this.#allTags.keys()];
  }
  /**
   * The original view (auto-layouted).
   * @see {@link $layouted} should be used for rendering in the UI
   */
  get $view() {
    if (!this.isLayouted() || "drifts" in this.#view) {
      return this.#view;
    }
    const snapshot = this.#manualLayoutSnapshot;
    if (snapshot) {
      return memoizeProp(this, "withDriftReasons", () => {
        return applyLayoutDriftReasons(this.#view, snapshot);
      });
    }
    return this.#view;
  }
  /**
   * Returns the view with manual layout applied if it exists, otherwise returns the original view
   * This should be used for rendering in the UI
   */
  get $layouted() {
    if (!this.isLayouted()) {
      throw new Error("View is not layouted");
    }
    return this.manualLayouted ?? this.#view;
  }
  get hasManualLayout() {
    return this.#manualLayoutSnapshot !== void 0;
  }
  /**
   * If view has manual layout, returns it with manual layout applied
   */
  get manualLayouted() {
    if (!this.isLayouted()) {
      return null;
    }
    const snapshot = this.#manualLayoutSnapshot;
    if (snapshot) {
      return memoizeProp(this, "snapshotWithManualLayout", () => {
        return applyManualLayout(this.#view, snapshot);
      });
    }
    return null;
  }
  /**
   * Returns the layout drift reasons, if any
   * (Only for layouted views with manual layout)
   */
  get driftReasons() {
    if (!this.isLayouted()) {
      return [];
    }
    return this.$view.drifts ?? [];
  }
  roots() {
    return this.#rootnodes.values();
  }
  /**
   * Iterate over all nodes that have children.
   */
  *compounds() {
    for (const node of this.#nodes.values()) {
      if (node.hasChildren()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Get node by id.
   * @throws Error if node is not found.
   */
  node(node) {
    const nodeId = getId(node);
    return nonNullable(this.#nodes.get(nodeId), `Node ${nodeId} not found in view ${this.#view.id}`);
  }
  /**
   * Find node by id.
   */
  findNode(node) {
    return this.#nodes.get(getId(node)) ?? null;
  }
  findNodeWithElement(element) {
    const id = getId(element);
    if (!this.#includeElements.has(id)) {
      return null;
    }
    return ifind(
      this.#nodes.values(),
      (node) => node.hasElement() && node.element.id === id
    ) ?? null;
  }
  /**
   * Iterate over all nodes.
   */
  nodes() {
    return this.#nodes.values();
  }
  /**
   * Get edge by id, throws error if edge is not found.
   * Use {@link findEdge} if you are not sure if the edge exists.
   *
   * @param edge Edge or id
   * @returns {@link EdgeModel}
   */
  edge(edge) {
    const edgeId = getId(edge);
    return nonNullable(this.#edges.get(edgeId), `Edge ${edgeId} not found in view ${this.#view.id}`);
  }
  /**
   * Find edge by id.
   * @param edge Edge or id
   * @returns {@link EdgeModel} or null if edge is not found
   */
  findEdge(edge) {
    return this.#edges.get(getId(edge)) ?? null;
  }
  /**
   * Iterate over all edges.
   */
  edges() {
    return this.#edges.values();
  }
  /**
   * Iterate over all edges.
   */
  *edgesWithRelation(relation) {
    for (const edge of this.#edges.values()) {
      if (edge.includesRelation(relation)) {
        yield edge;
      }
    }
    return;
  }
  /**
   * Nodes that have references to elements from logical model.
   */
  *elements() {
    for (const node of this.#nodes.values()) {
      if (node.hasElement()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Checks if the view has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
  includesElement(element) {
    return this.#includeElements.has(getId(element));
  }
  includesDeployment(deployment) {
    return this.#includeDeployments.has(getId(deployment));
  }
  includesRelation(relation) {
    return this.#includeRelations.has(getId(relation));
  }
  /**
   * Below are type guards.
   */
  isComputed() {
    return this.#view[_stage] === "computed";
  }
  isLayouted() {
    return this.#view[_stage] === "layouted";
  }
  /**
   * @deprecated Use {@link isLayouted} instead
   */
  isDiagram() {
    return this.#view[_stage] === "layouted";
  }
  isElementView() {
    return this.#view[_type] === "element";
  }
  isScopedElementView() {
    return this.#view[_type] === "element" && e$3(this.#view.viewOf);
  }
  isDeploymentView() {
    return this.#view[_type] === "deployment";
  }
  isDynamicView() {
    return this.#view[_type] === "dynamic";
  }
}

class LikeC4ViewsFolder {
  $model;
  /**
   * Path to this view folder, processed by {@link normalizeViewPath}
   *
   * @example
   * "Folder 1/Folder 2/Folder 3"
   */
  path;
  /**
   * Title of this view folder.
   *
   * @example
   * // title is the last segment of the path
   * path = "Folder 1/Folder 2/Folder 3"
   * title = "Folder 3"
   */
  title;
  /**
   * Whether this is the root view folder.
   *
   * !NOTE
   * Root folder is special folder with an empty path and used only for internal purposes. \
   * It is not visible to the user and should not be used in the code.
   */
  isRoot;
  parentPath;
  defaultViewId;
  constructor($model, path, defaultViewId) {
    this.$model = $model;
    this.path = path.join("/");
    this.isRoot = this.path === "";
    this.title = t$4(path);
    if (this.isRoot) {
      this.parentPath = void 0;
    } else {
      this.parentPath = path.slice(0, -1).join("/");
    }
    this.defaultViewId = defaultViewId;
  }
  /**
   * Default view of this view folder.\
   * It is for the case when there is a view at the same path as this folder.\
   * (if there are multiple views at the same path, the first one is chosen)
   *
   * @example
   * ```
   * // Assume the following views exist:
   * const views = [
   *   "Folder 1/ Folder 2 / View",
   *   "Folder 1/ Folder 2 / View / Subview",
   * ]
   * ```
   * Group with path `Folder 1/ Folder 2 / View`\
   * will have default view `Folder 1/ Folder 2 / View`
   */
  get defaultView() {
    if (!this.defaultViewId) {
      return null;
    }
    return this.$model.view(this.defaultViewId);
  }
  /**
   * Returns path to this view folder as an array of ancestors (excluding root) and this view folder as the last element
   *
   * @throws Error if this is the root folder.
   */
  get breadcrumbs() {
    invariant(!this.isRoot, "Root view folder has no breadcrumbs");
    return memoizeProp(this, "breadcrumbs", () => {
      const parent = this.parent;
      if (parent) {
        if (parent.isRoot) {
          return [parent, this];
        }
        return [...parent.breadcrumbs, this];
      }
      return [this];
    });
  }
  /**
   * Returns parent folder
   *
   * @throws Error if this is the root folder.
   */
  get parent() {
    invariant(!this.isRoot, "Root view folder has no parent");
    if (e$4(this.parentPath)) {
      return null;
    }
    return this.$model.viewFolder(this.parentPath);
  }
  /**
   * Returns sorted set of children
   * - First folders
   * - Then views
   */
  get children() {
    return this.$model.viewFolderItems(this.path);
  }
  /**
   * Returns sorted array of children folders
   */
  get folders() {
    return memoizeProp(this, "folders", () => {
      const folders = [];
      for (const child of this.children) {
        if (child instanceof LikeC4ViewsFolder) {
          folders.push(child);
        }
      }
      return folders;
    });
  }
  /**
   * Returns all views in this view folder.
   */
  get views() {
    return memoizeProp(this, "views", () => {
      const views = [];
      for (const child of this.children) {
        if (child instanceof LikeC4ViewModel) {
          views.push(child);
        }
      }
      return views;
    });
  }
}

class LikeC4Model {
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  _elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  _parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  _children = new DefaultMap(() => /* @__PURE__ */ new Set());
  _rootElements = /* @__PURE__ */ new Set();
  _relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  _incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  _outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  _internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  _views = /* @__PURE__ */ new Map();
  _rootViewFolder;
  _viewFolders = /* @__PURE__ */ new Map();
  _viewFolderItems = new DefaultMap(() => /* @__PURE__ */ new Set());
  _allTags = new DefaultMap(() => /* @__PURE__ */ new Set());
  static fromParsed(model) {
    return new LikeC4Model(model);
  }
  static create(model) {
    return new LikeC4Model(model);
  }
  /**
   * Creates a new LikeC4Model instance and infers types from a model dump.\
   * Model dump expected to be computed or layouted.
   *
   * @typeParam D - A constant type parameter extending LikeC4ModelDump
   * @param dump - The model dump to create the instance from
   * @returns A  new LikeC4Model instance with types inferred from the dump
   */
  static fromDump(dump) {
    const {
      _stage: stage = "layouted",
      projectId = "unknown",
      project,
      globals,
      imports,
      deployments,
      views,
      relations,
      elements,
      specification
    } = dump;
    return new LikeC4Model({
      [_stage]: stage,
      projectId,
      project,
      globals: {
        predicates: globals?.predicates ?? {},
        dynamicPredicates: globals?.dynamicPredicates ?? {},
        styles: globals?.styles ?? {}
      },
      imports: imports ?? {},
      deployments: {
        elements: deployments?.elements ?? {},
        relations: deployments?.relations ?? {}
      },
      views: views ?? {},
      relations: relations ?? {},
      elements: elements ?? {},
      specification
    });
  }
  deployment;
  $data;
  constructor($data) {
    this.$data = $data;
    for (const [, element] of t$d($data.elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this._allTags.get(tag).add(el);
      }
    }
    for (const [projectId, elements] of t$d($data.imports ?? {})) {
      for (const element of sortParentsFirst(elements)) {
        const el = this.addImportedElement(projectId, element);
        for (const tag of el.tags) {
          this._allTags.get(tag).add(el);
        }
      }
    }
    for (const relation of t($data.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this._allTags.get(tag).add(el);
      }
    }
    this.deployment = new LikeC4DeploymentModel(this);
    if (isOnStage($data, "computed") || isOnStage($data, "layouted")) {
      const compare = compareNaturalHierarchically(VIEW_FOLDERS_SEPARATOR);
      t($data.views);
      const views = t$a(
        t($data.views),
        t$e((view) => ({
          view,
          path: normalizeViewPath(view.title ?? view.id),
          folderPath: view.title && getViewFolderPath(view.title) || ""
        })),
        // Sort hierarchically by groups, but keep same order within groups
        t$g((a, b) => compare(a.folderPath, b.folderPath))
      );
      const getOrCreateFolder = (path) => {
        let folder = this._viewFolders.get(path);
        if (!folder) {
          const segments = e(path, VIEW_FOLDERS_SEPARATOR);
          invariant(t$c(segments, 1), `View group path "${path}" must have at least one element`);
          let defaultView;
          if (path === "") {
            defaultView = views.find((view) => view.view.id === "index");
          } else {
            defaultView = views.find((view) => view.path === path);
          }
          folder = new LikeC4ViewsFolder(this, segments, defaultView?.view.id);
          this._viewFolders.set(path, folder);
        }
        return folder;
      };
      this._rootViewFolder = getOrCreateFolder("");
      for (const { folderPath } of views) {
        if (this._viewFolders.has(folderPath)) {
          continue;
        }
        e(folderPath, VIEW_FOLDERS_SEPARATOR).reduce((segments, segment) => {
          const parent = segments.join(VIEW_FOLDERS_SEPARATOR);
          const path = e$4(parent) ? segment : parent + VIEW_FOLDERS_SEPARATOR + segment;
          const folder = getOrCreateFolder(path);
          this._viewFolderItems.get(parent).add(folder);
          segments.push(segment);
          return segments;
        }, []);
      }
      for (const { view, folderPath } of views) {
        const vm = new LikeC4ViewModel(
          this,
          getOrCreateFolder(folderPath),
          view,
          $data.manualLayouts?.[view.id]
        );
        this._viewFolderItems.get(folderPath).add(vm);
        this._views.set(view.id, vm);
        for (const tag of vm.tags) {
          this._allTags.get(tag).add(vm);
        }
      }
    } else {
      this._rootViewFolder = new LikeC4ViewsFolder(this, [""], void 0);
      this._viewFolders.set(this._rootViewFolder.path, this._rootViewFolder);
    }
  }
  /**
   * Type narrows the model to the parsed stage.
   * This is useful for tests
   */
  get asParsed() {
    return this;
  }
  /**
   * Type narrows the model to the layouted stage.
   * This is useful for tests
   */
  get asComputed() {
    return this;
  }
  /**
   * Type narrows the model to the layouted stage.
   * This is useful for tests
   */
  get asLayouted() {
    return this;
  }
  /**
   * Returns the styles configuration for the project.
   */
  get $styles() {
    return memoizeProp(
      this,
      "styles",
      () => LikeC4Styles.from(
        this.$data.project.styles,
        this.$data.specification.customColors ? {
          theme: {
            colors: this.$data.specification.customColors
          }
        } : void 0
      )
    );
  }
  /**
   * Type guard the model to the parsed stage.
   */
  isParsed() {
    return this.stage === "parsed";
  }
  /**
   * Type guard the model to the layouted stage.
   */
  isLayouted() {
    return this.stage === "layouted";
  }
  /**
   * Type guard the model to the computed stage.
   */
  isComputed() {
    return this.stage === "computed";
  }
  /**
   * Keeping here for backward compatibility
   * @deprecated use {@link $data}
   */
  get $model() {
    return this.$data;
  }
  get stage() {
    return this.$data[_stage];
  }
  /**
   * Returns the Project ID associated with the model.
   * If the project ID is not defined in the model, it returns "default".
   */
  get projectId() {
    return this.$data.projectId ?? "default";
  }
  /**
   * Returns the project associated with the model.
   * If the project is not defined in the model, it returns a default project with the ID "default".
   */
  get project() {
    return this.$data.project ?? memoizeProp(this, Symbol.for("project"), () => ({
      id: this.projectId
    }));
  }
  get specification() {
    return this.$data.specification;
  }
  get globals() {
    return memoizeProp(this, Symbol.for("globals"), () => ({
      predicates: {
        ...this.$data.globals?.predicates
      },
      dynamicPredicates: {
        ...this.$data.globals?.dynamicPredicates
      },
      styles: {
        ...this.$data.globals?.styles
      }
    }));
  }
  /**
     * Returns the element with the given FQN.
     *
     * @throws Error if element is not found\
     * Use {@link findElement} if you don't want to throw an error
     *
     * @note Method is type-safe for typed model
  
     * @example
     * model.element('cloud.frontend')
     * // or object with id property of scalar.Fqn
     * model.element({
     *   id: 'dashboard',
     * })
     */
  element(el) {
    if (el instanceof ElementModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this._elements.get(id), `Element ${id} not found`);
  }
  /**
   * Returns the element with the given FQN.
   *
   * @returns Element if found, null otherwise
   * @note Method is not type-safe as {@link element}
   *
   * @example
   * model.findElement('cloud.frontend')
   */
  findElement(el) {
    return this._elements.get(getId(el)) ?? null;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this._rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this._elements.values();
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this._relations.values();
  }
  relationship(rel, type) {
    if (type === "deployment") {
      return this.deployment.relationship(rel);
    }
    const id = getId(rel);
    let model = this._relations.get(id) ?? null;
    if (model || type === "model") {
      return nonNullable(model, `Model relation ${id} not found`);
    }
    return nonNullable(this.deployment.findRelationship(id), `No model/deployment relation ${id} not found`);
  }
  findRelationship(id, type) {
    if (type === "deployment") {
      return this.deployment.findRelationship(id);
    }
    let model = this._relations.get(getId(id)) ?? null;
    if (model || type === "model") {
      return model;
    }
    return this.deployment.findRelationship(id);
  }
  /**
   * Returns all views in the model.
   */
  views() {
    return this._views.values();
  }
  /**
   * Returns a specific view by its ID.
   * @note Method is type-safe for typed model
   * @throws Error if view is not found\
   * Use {@link findView} if you don't want to throw an error
   *
   * @example
   * model.view('index')
   * // or object with id property of scalar.ViewId
   * model.view({
   *   id: 'index',
   * })
   */
  view(viewId) {
    const id = getId(viewId);
    return nonNullable(this._views.get(id), `View ${id} not found`);
  }
  /**
   * Returns a specific view by its ID.
   * @note Method is not type-safe as {@link view}
   *
   * @example
   * model.findView('index')
   */
  findView(viewId) {
    return this._views.get(viewId) ?? null;
  }
  /**
   * Returns a view folder by its path.
   * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
   * @throws Error if view folder is not found.
   */
  viewFolder(path) {
    return nonNullable(this._viewFolders.get(path), `View folder ${path} not found`);
  }
  /**
   * Root folder is a special one with an empty path and used only for internal purposes.
   * It is not visible to the user and should be used only to get top-level folders and views.
   */
  get rootViewFolder() {
    return this._rootViewFolder;
  }
  /**
   * Whether the model has any view folders.
   */
  get hasViewFolders() {
    return this._viewFolders.size > 1;
  }
  /**
   * Returns all children of a view folder.
   * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
   *
   * @throws Error if view folder is not found.
   */
  viewFolderItems(path) {
    invariant(this._viewFolders.has(path), `View folder ${path} not found`);
    return this._viewFolderItems.get(path);
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this._parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this._children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const parent = this._parents.get(id);
    const siblings = parent ? this._children.get(parent.id).values() : this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = this._parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element) {
    for (const child of this.children(element)) {
      yield child;
      yield* this.descendants(child.id);
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this._incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this._outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Returns array of all tags used in the model, sorted naturally.\
   * Use {@link specification.tags} to get all defined tags
   */
  get tags() {
    return memoizeProp(this, "tags", () => t$g([...this._allTags.keys()], compareNatural));
  }
  /**
   * Returns all tags used in the model, sorted by usage count (descending).
   */
  get tagsSortedByUsage() {
    return memoizeProp(this, "tagsSortedByUsage", () => t$a(
      [...this._allTags.entries()],
      t$e(([tag, tagged]) => ({
        tag,
        count: tagged.size,
        tagged
      })),
      t$g((a, b) => compareNatural(a.tag, b.tag)),
      t$1(
        [e$5("count"), "desc"]
      )
    ));
  }
  findByTag(tag, type) {
    return ifilter(this._allTags.get(tag), (el) => {
      if (type === "elements") {
        return el instanceof ElementModel;
      }
      if (type === "views") {
        return el instanceof LikeC4ViewModel;
      }
      if (type === "relationships") {
        return el instanceof RelationshipModel;
      }
      return true;
    });
  }
  /**
   * Returns all elements of the given kind.
   */
  *elementsOfKind(kind) {
    for (const el of this._elements.values()) {
      if (el.kind === kind) {
        yield el;
      }
    }
    return;
  }
  /**
   * Returns all elements that match the given where operator.
   *
   * @example
   * ```ts
   * model.where({
   *   and: [
   *     { kind: 'component' },
   *     {
   *       or: [
   *         { tag: 'old' },
   *         { tag: { neq: 'new' } },
   *       ],
   *     },
   *   ],
   * })
   * ```
   */
  *elementsWhere(where) {
    const predicate = whereOperatorAsPredicate(where);
    for (const el of this._elements.values()) {
      if (predicate(el)) {
        yield el;
      }
    }
    return;
  }
  /**
   * Returns all **model** relationships that match the given where operator.
   *
   * @example
   * ```ts
   * model.relationshipsWhere({
   *   and: [
   *     { kind: 'uses' },
   *     {
   *       or: [
   *         { tag: 'old' },
   *         { tag: { neq: 'new' } },
   *       ],
   *     },
   *   ],
   * })
   * ```
   */
  *relationshipsWhere(where) {
    const predicate = whereOperatorAsPredicate(where);
    for (const rel of this._relations.values()) {
      if (predicate(rel)) {
        yield rel;
      }
    }
    return;
  }
  addElement(element) {
    if (this._elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = new ElementModel(this, Object.freeze(element));
    this._elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this._elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this._parents.set(el.id, this.element(parentId));
      this._children.get(parentId).add(el);
    } else {
      this._rootElements.add(el);
    }
    return el;
  }
  addImportedElement(projectId, element) {
    invariant(!isGlobalFqn(element.id), `Imported element already has global FQN`);
    const id = GlobalFqn(projectId, element.id);
    if (this._elements.has(id)) {
      throw new Error(`Element ${id} already exists`);
    }
    const el = new ElementModel(
      this,
      Object.freeze({
        ...element,
        id
      })
    );
    this._elements.set(el.id, el);
    let parentId = parentFqn(el.id);
    while (parentId) {
      if (parentId.includes(".") && this._elements.has(parentId)) {
        this._parents.set(el.id, this.element(parentId));
        this._children.get(parentId).add(el);
        return el;
      }
      parentId = parentFqn(parentId);
    }
    this._rootElements.add(el);
    return el;
  }
  addRelation(relation) {
    if (this._relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new RelationshipModel(
      this,
      Object.freeze(relation)
    );
    const { source, target } = rel;
    this._relations.set(rel.id, rel);
    this._incoming.get(target.id).add(rel);
    this._outgoing.get(source.id).add(rel);
    const relParent = commonAncestor(source.id, target.id);
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this._internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this._outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      this._incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}
((LikeC4Model2) => {
  LikeC4Model2.EMPTY = LikeC4Model2.create({
    _stage: "computed",
    projectId: "default",
    project: { id: "default" },
    specification: {
      elements: {},
      relationships: {},
      deployments: {},
      tags: {}
    },
    globals: {
      predicates: {},
      dynamicPredicates: {},
      styles: {}
    },
    deployments: {
      elements: {},
      relations: {}
    },
    elements: {},
    relations: {},
    views: {},
    imports: {}
  });
})(LikeC4Model || (LikeC4Model = {}));

function isDeploymentNodeModel(model) {
  return model instanceof DeploymentNodeModel;
}
function isDeployedInstanceModel(model) {
  return model instanceof DeployedInstanceModel;
}
function isDeploymentElementModel(model) {
  return isDeploymentNodeModel(model) || isDeployedInstanceModel(model);
}
function isNestedElementOfDeployedInstanceModel(model) {
  return model instanceof NestedElementOfDeployedInstanceModel;
}
function isDeploymentRelationModel(x) {
  return x instanceof DeploymentRelationModel;
}
function isRelationModel(x) {
  return x instanceof RelationshipModel;
}
function isElementModel(element) {
  return element instanceof ElementModel;
}
function isLikeC4ViewModel(view) {
  return view instanceof LikeC4ViewModel;
}
function isNodeModel(node) {
  return node instanceof NodeModel;
}
function isEdgeModel(edge) {
  return edge instanceof EdgeModel;
}

export { isEdgeModel as A, ElementModel as E, LikeC4Model as L, NodeModel as N, RelationshipModel as R, VIEW_FOLDERS_SEPARATOR as V, t$3 as a, t$4 as b, t$2 as c, t$5 as d, t$6 as e, isNestedElementOfDeployedInstanceModel as f, isDeployedInstanceModel as g, isDeploymentNodeModel as h, isElementModel as i, isDeploymentElementModel as j, buildElementNotations as k, LikeC4DeploymentModel as l, EdgeModel as m, n$5 as n, LikeC4ViewModel as o, LikeC4ViewsFolder as p, extractViewTitleFromPath as q, getViewFolderPath as r, normalizeViewPath as s, t, applyLayoutDriftReasons as u, applyManualLayout as v, isDeploymentRelationModel as w, isRelationModel as x, isLikeC4ViewModel as y, isNodeModel as z };
