import { Tagged, NonEmptyTuple, IsNever, PartialDeep, WritableDeep, Except } from 'type-fest';
import { s as BorderStyle, q as ShapeSize, r as SpacingSize, p as TextSize, Q as Color, u as ElementShape, v as RelationshipLineType, y as RelationshipArrowType, D as ThemeColor, C as ColorLiteral, I as CustomColorDefinitions, b as LikeC4Theme, L as LikeC4StyleDefaults } from './core.BnOetIAR.mjs';
import { A as Any, s as WithOptionalTags, u as WithOptionalLinks, m as StrictViewId, j as _stage, k as _type, F as Fqn, R as RelationKind, W as WithDescriptionAndTech, v as WithMetadata, w as WithNotation, n as ElementKind, T as Tag, y as DeploymentKind, C as MetadataKey, G as WithTags, x as DeploymentFqn } from './core.CDOKQTW6.mjs';
import { N as NonEmptyArray, E as ExclusiveUnion, a as NonEmptyReadonlyArray, L as Link } from './core.DB0Ue5Wx.mjs';
import { I as Icon, M as MarkdownOrString, d as RelationId, T as Tag$1, P as ProjectId, N as NodeId, j as EdgeId, m as StepEdgeKind } from './core.DX-WYEPA.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { ModelExpression, ModelFqnExpr } from '../types/expression-model.mjs';

type Point = readonly [x: number, y: number];
interface XYPoint {
    x: number;
    y: number;
}
interface BBox {
    x: number;
    y: number;
    width: number;
    height: number;
}
declare namespace BBox {
    function center({ x, y, width, height }: BBox): XYPoint;
    function fromPoints(points: Point[]): BBox;
    function merge(...boxes: BBox[]): BBox;
    function fromRectBox(rect: RectBox): BBox;
    function toRectBox(box: BBox): RectBox;
    function expand(box: BBox, plus: number): BBox;
    function shrink(box: BBox, minus: number): BBox;
    /**
     * Returns true if `a` includes `b` (i.e. `b` is inside `a`)
     */
    function includes(a: BBox, b: BBox): boolean;
}
interface RectBox {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
}
declare namespace RectBox {
    function center({ x1, y1, x2, y2 }: RectBox): XYPoint;
    function fromPoints(points: Point[]): RectBox;
    function merge(...boxes: RectBox[]): RectBox;
    function toBBox(box: RectBox): BBox;
    /**
     * Returns true if `a` includes `b` (i.e. `b` is inside `a`)
     */
    function includes(a: RectBox, b: RectBox): boolean;
}

interface AnyIncludePredicate<Expr> {
    include: Expr[];
    exclude?: never;
}
interface AnyExcludePredicate<Expr> {
    include?: never;
    exclude: Expr[];
}
interface AnyViewRuleStyle<Expr> {
    targets: Expr[];
    notation?: string;
    style: {
        border?: BorderStyle;
        opacity?: number;
        multiple?: boolean;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
        color?: Color;
        shape?: ElementShape;
        icon?: Icon;
    };
}
interface ViewRuleGlobalStyle {
    styleId: GlobalStyleID;
}
declare function isViewRuleGlobalStyle(rule: object): rule is ViewRuleGlobalStyle;
interface ViewRuleGlobalPredicateRef {
    predicateId: GlobalPredicateId;
}
declare function isViewRuleGlobalPredicateRef(rule: object): rule is ViewRuleGlobalPredicateRef;
type AutoLayoutDirection = 'TB' | 'BT' | 'LR' | 'RL';
declare function isAutoLayoutDirection(autoLayout: unknown): autoLayout is AutoLayoutDirection;
interface ViewRuleAutoLayout {
    direction: AutoLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare function isViewRuleAutoLayout(rule: object): rule is ViewRuleAutoLayout;
interface ViewAutoLayout {
    direction: ViewRuleAutoLayout['direction'];
    rankSep?: number;
    nodeSep?: number;
}
/**
 * v1 Manual layout of a view, stored in the block comment to the view definition.
 * Keeping this type for backward compatibility and migration purposes.
 *
 * @deprecated Use {@link ViewManualLayoutSnapshot} instead
 */
type ViewManualLayout = {
    readonly hash: string;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: Record<string, {
        isCompound: boolean;
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    readonly edges: Record<string, {
        dotpos?: string;
        points: NonEmptyArray<Point>;
        controlPoints?: NonEmptyArray<XYPoint>;
        labelBBox?: BBox;
    }>;
};
type ViewType = 'element' | 'dynamic' | 'deployment';
interface BaseViewProperties<A extends Any> extends WithOptionalTags<A>, WithOptionalLinks {
    readonly id: StrictViewId<A>;
    readonly title: string | null;
    readonly description: MarkdownOrString | null;
    /**
     * Source file containing this view, relative to the project root.
     * Undefined if the view is auto-generated.
     */
    readonly sourcePath?: string | undefined;
}
interface BaseParsedViewProperties<A extends Any> extends BaseViewProperties<A> {
    /**
     * Internal field to identify the stage of the view.
     * This is used to create the correct type of the view.
     */
    readonly [_stage]: 'parsed';
    /**
     * URI to the source file of this view.
     * Undefined if the view is auto-generated.
     */
    readonly docUri?: string | undefined;
}
type NodeNotation = {
    kinds: string[];
    shape: ElementShape;
    color: Color;
    title: string;
};
interface ViewWithNotation {
    notation?: {
        nodes: NodeNotation[];
    };
}
interface ViewWithHash {
    /**
     * Hash of the view object.
     * This is used to detect changes in layout
     */
    hash: string;
}

/**
 * Predicates scoped to logical model
 */
interface ElementViewIncludePredicate<A extends Any = Any> extends AnyIncludePredicate<ModelExpression<A>> {
}
interface ElementViewExcludePredicate<A extends Any = Any> extends AnyExcludePredicate<ModelExpression<A>> {
}
type ElementViewPredicate<A extends Any = Any> = ElementViewIncludePredicate<A> | ElementViewExcludePredicate<A>;
interface ElementViewRuleGroup<A extends Any = Any> {
    groupRules: Array<ElementViewPredicate<A> | ElementViewRuleGroup<A>>;
    title: string | null;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
declare function isViewRuleGroup<A extends Any>(rule: ElementViewRule<A>): rule is ElementViewRuleGroup<A>;
interface ElementViewRuleStyle<A extends Any = Any> extends AnyViewRuleStyle<ModelFqnExpr<A>> {
}
type ElementViewRule<A extends Any = Any> = ExclusiveUnion<{
    IncludePredicate: ElementViewIncludePredicate<A>;
    ExcludePredicate: ElementViewExcludePredicate<A>;
    Group: ElementViewRuleGroup<A>;
    Style: ElementViewRuleStyle<A>;
    GlobalStyle: ViewRuleGlobalStyle;
    GlobalPredicateRef: ViewRuleGlobalPredicateRef;
    AutoLayout: ViewRuleAutoLayout;
}>;
interface ParsedElementView<A extends Any = Any> extends BaseParsedViewProperties<A> {
    [_type]: 'element';
    readonly rules: ElementViewRule<A>[];
    readonly viewOf?: Fqn<A>;
    readonly extends?: StrictViewId<A>;
}

interface DynamicStep<A extends Any = Any> {
    readonly source: Fqn<A>;
    readonly target: Fqn<A>;
    readonly title?: string | null;
    readonly kind?: RelationKind<A>;
    readonly description?: MarkdownOrString;
    readonly technology?: string;
    readonly notation?: string;
    readonly notes?: MarkdownOrString;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly isBackward?: boolean;
    readonly navigateTo?: StrictViewId<A>;
    /**
     * Path to the AST node relative to the view body ast
     * Used to locate the step in the source code
     */
    readonly astPath: string;
}
interface DynamicStepsSeries<A extends Any = Any> {
    readonly seriesId: string;
    readonly __series: NonEmptyReadonlyArray<DynamicStep<A>>;
}
interface DynamicStepsParallel<A extends Any = Any> {
    readonly parallelId: string;
    readonly __parallel: NonEmptyReadonlyArray<DynamicStep<A> | DynamicStepsSeries<A>>;
}
declare function getParallelStepsPrefix(id: string): string | null;
type DynamicViewStep<A extends Any = Any> = ExclusiveUnion<{
    Step: DynamicStep<A>;
    Series: DynamicStepsSeries<A>;
    Parallel: DynamicStepsParallel<A>;
}>;
declare function isDynamicStep<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStep<A>;
declare function isDynamicStepsParallel<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStepsParallel<A>;
declare function isDynamicStepsSeries<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStepsSeries<A>;
interface DynamicViewIncludeRule<A extends Any = Any> {
    include: ModelFqnExpr.Any<A>[];
}
type DynamicViewRule<A extends Any = Any> = ExclusiveUnion<{
    Include: DynamicViewIncludeRule<A>;
    GlobalPredicateRef: ViewRuleGlobalPredicateRef;
    ElementViewRuleStyle: ElementViewRuleStyle<A>;
    GlobalStyle: ViewRuleGlobalStyle;
    AutoLayout: ViewRuleAutoLayout;
}>;
type DynamicViewDisplayVariant = 'diagram' | 'sequence';
interface ParsedDynamicView<A extends Any = Any> extends BaseParsedViewProperties<A> {
    [_type]: 'dynamic';
    /**
     * How to display the dynamic view
     * - `diagram`: display as a regular likec4 view
     * - `sequence`: display as a sequence diagram
     *
     * @default 'diagram'
     */
    readonly variant?: DynamicViewDisplayVariant;
    readonly steps: DynamicViewStep<A>[];
    readonly rules: DynamicViewRule<A>[];
}

type GlobalPredicateId = Tagged<string, 'GlobalPredicateId'>;
type GlobalPredicates<A extends Any = Any> = NonEmptyArray<ElementViewPredicate<A>>;
type GlobalDynamicPredicates<A extends Any = Any> = NonEmptyArray<DynamicViewIncludeRule<A>>;
type GlobalStyleID = Tagged<string, 'GlobalStyleID'>;
type GlobalStyles<A extends Any = Any> = NonEmptyTuple<ElementViewRuleStyle<A>>;
interface ModelGlobals<A extends Any = Any> {
    readonly predicates: Record<GlobalPredicateId, GlobalPredicates<A>>;
    readonly dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates<A>>;
    readonly styles: Record<GlobalStyleID, GlobalStyles<A>>;
}

interface ElementStyle {
    readonly icon?: Icon;
    readonly shape?: ElementShape;
    readonly color?: Color;
    readonly border?: BorderStyle;
    /**
     * In percentage 0-100, 0 is fully transparent
     *
     * @default 100
     */
    readonly opacity?: number;
    /**
     * If true, the element is rendered as multiple shapes
     * @default false
     */
    readonly multiple?: boolean;
    /**
     * Shape size
     *
     * @default 'md'
     */
    readonly size?: ShapeSize;
    readonly padding?: SpacingSize;
    readonly textSize?: TextSize;
}
type WithSizes = Pick<ElementStyle, 'size' | 'padding' | 'textSize'>;
/**
 * Ensures that the sizes are set to default values if they are not set
 */
declare function ensureSizes<S extends WithSizes>({ size, padding, textSize, ...rest }: S, defaultSize?: "xs" | "sm" | "md" | "lg" | "xl"): Omit<S, 'size' | 'padding' | 'textSize'> & Required<WithSizes>;
interface Element<A extends Any = Any> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A>, WithNotation {
    readonly id: Fqn<A>;
    readonly kind: ElementKind<A>;
    readonly title: string;
    readonly style: ElementStyle;
}
interface AbstractRelationship<A extends Any> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A> {
    readonly id: RelationId;
    readonly title?: string | null;
    readonly kind?: RelationKind<A>;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly navigateTo?: StrictViewId<A>;
}
/**
 * Relationship between two model elements
 */
interface Relationship<A extends Any = Any> extends AbstractRelationship<A> {
    readonly source: FqnRef.ModelRef<A>;
    readonly target: FqnRef.ModelRef<A>;
}
/**
 * Backward compatibility alias
 * @deprecated Use {@link Relationship} instead
 */
type ModelRelation<A extends Any = Any> = Relationship<A>;

/**
 * Element and deployment kind specification
 */
interface ElementSpecification {
    tags?: Tag$1[];
    title?: string;
    summary?: MarkdownOrString;
    description?: MarkdownOrString;
    technology?: string;
    notation?: string;
    links?: NonEmptyArray<Link>;
    style: {
        shape?: ElementShape;
        icon?: Icon;
        color?: Color;
        border?: BorderStyle;
        opacity?: number;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
        multiple?: boolean;
    };
}
interface TagSpecification {
    color: ThemeColor | ColorLiteral;
}
/**
 * Checks if tag color is defined in the specification
 * Expects HEX, `rgb(...)` or `rgba(...)` color
 */
declare function isTagColorSpecified(spec: string | TagSpecification): spec is {
    color: ColorLiteral;
};
interface RelationshipSpecification {
    technology?: string;
    notation?: string;
    color?: Color;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
}
type Specification<A> = A extends Any ? {
    tags: {
        [key in Tag<A>]: TagSpecification;
    };
    elements: {
        [key in ElementKind<A>]: Partial<ElementSpecification>;
    };
    deployments: {
        [key in DeploymentKind<A>]: Partial<ElementSpecification>;
    };
    relationships: {
        [key in RelationKind<A>]: Partial<RelationshipSpecification>;
    };
    metadataKeys?: IsNever<MetadataKey<A>> extends true ? never : MetadataKey<A>[];
    customColors?: CustomColorDefinitions;
} : never;

type LikeC4ProjectTheme = PartialDeep<WritableDeep<LikeC4Theme>, {
    recurseIntoArrays: false;
    allowUndefinedInNonTupleArrays: false;
}>;
type LikeC4ProjectStyleDefaults = PartialDeep<WritableDeep<LikeC4StyleDefaults>, {
    recurseIntoArrays: false;
    allowUndefinedInNonTupleArrays: false;
}>;
interface LikeC4ProjectStylesConfig {
    theme?: LikeC4ProjectTheme;
    defaults?: LikeC4ProjectStyleDefaults;
}
interface LikeC4ProjectManualLayoutsConfig {
    outDir: string;
}
/**
 * Configuration of the project, as read from the config file.
 * LikeC4 projects encapsulate models, and can import from each other
 */
interface LikeC4Project {
    /**
     * ID of the project, casted to {@link scalar.ProjectId}
     */
    readonly id: ProjectId;
    title?: string;
    /**
     * Custom styles
     */
    styles?: LikeC4ProjectStylesConfig | undefined;
    manualLayouts?: LikeC4ProjectManualLayoutsConfig | undefined;
}

type ComputedNodeStyle = Except<ElementStyle, 'icon' | 'shape' | 'color', {
    requireExactProps: true;
}>;
interface ComputedNode<A extends Any = Any> extends WithTags<A>, WithOptionalLinks {
    id: NodeId;
    kind: ElementKind<A> | DeploymentKind<A> | '@group';
    parent: NodeId | null;
    /**
     * Reference to model element
     */
    modelRef?: Fqn<A>;
    /**
     * Reference to deployment element
     */
    deploymentRef?: DeploymentFqn<A>;
    title: string;
    /**
     * Description of the node
     * either summary or description
     */
    description?: MarkdownOrString | null;
    technology?: string | null;
    children: NodeId[];
    inEdges: EdgeId[];
    outEdges: EdgeId[];
    shape: ElementShape;
    color: Color;
    icon?: Icon;
    style: ComputedNodeStyle;
    navigateTo?: StrictViewId<A> | null;
    level: number;
    depth?: number | null;
    /**
     * If this node was customized in the view
     */
    isCustomized?: boolean;
    notation?: string | null;
}
interface ComputedEdge<A extends Any = Any> extends WithOptionalTags<A> {
    id: EdgeId;
    parent: NodeId | null;
    source: NodeId;
    target: NodeId;
    label: string | null;
    description?: MarkdownOrString | null;
    technology?: string | null;
    relations: RelationId[];
    kind?: RelationKind<A> | typeof StepEdgeKind;
    notation?: string;
    notes?: MarkdownOrString;
    color: Color;
    line: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    navigateTo?: StrictViewId<A> | null;
    /**
     * If this edge is derived from custom relationship predicate
     */
    isCustomized?: boolean;
    /**
     * Path to the AST node relative to the view body ast
     * Available only in dynamic views
     * @internal
     */
    astPath?: string;
    /**
     * For layouting purposes
     * @default 'forward'
     */
    dir?: 'forward' | 'back' | 'both';
}
interface BaseComputedViewProperties<A extends Any> extends BaseViewProperties<A>, ViewWithHash, ViewWithNotation {
    readonly [_stage]: 'computed';
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode<A>[];
    readonly edges: ComputedEdge<A>[];
    /**
     * If the view has manual layout (v2)
     */
    readonly hasManualLayout?: boolean;
    /**
     * Manual layout data (v1), for compatibility during migration
     * @deprecated
     */
    readonly manualLayout?: ViewManualLayout | undefined;
}
interface ComputedElementView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'element';
    readonly viewOf?: Fqn<A>;
    readonly extends?: StrictViewId<A>;
}
interface ComputedDeploymentView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'deployment';
}
interface ComputedDynamicView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'dynamic';
    /**
     * How to display the dynamic view
     * - `diagram`: display as a regular likec4 view
     * - `sequence`: display as a sequence diagram
     */
    readonly variant: DynamicViewDisplayVariant;
}

export { type DynamicStepsParallel as $, type AbstractRelationship as A, BBox as B, type ViewManualLayout as C, type ViewType as D, type ElementStyle as E, type BaseViewProperties as F, type GlobalPredicateId as G, type BaseParsedViewProperties as H, type ViewWithNotation as I, type ViewWithHash as J, type ComputedNodeStyle as K, type LikeC4ProjectTheme as L, type ModelGlobals as M, type NodeNotation as N, type ComputedNode as O, type Point as P, type ComputedEdge as Q, RectBox as R, type Specification as S, type TagSpecification as T, type ComputedElementView as U, type ViewRuleGlobalStyle as V, type ComputedDeploymentView as W, type XYPoint as X, type ComputedDynamicView as Y, type DynamicStep as Z, type DynamicStepsSeries as _, type GlobalPredicates as a, getParallelStepsPrefix as a0, type DynamicViewStep as a1, isDynamicStep as a2, isDynamicStepsParallel as a3, isDynamicStepsSeries as a4, type DynamicViewIncludeRule as a5, type DynamicViewRule as a6, type DynamicViewDisplayVariant as a7, type ParsedDynamicView as a8, type ElementViewIncludePredicate as a9, type ElementViewExcludePredicate as aa, type ElementViewPredicate as ab, type ElementViewRuleGroup as ac, isViewRuleGroup as ad, type ElementViewRuleStyle as ae, type ElementViewRule as af, type ParsedElementView as ag, type GlobalDynamicPredicates as b, type GlobalStyleID as c, type GlobalStyles as d, ensureSizes as e, type Element as f, type Relationship as g, type ModelRelation as h, type ElementSpecification as i, isTagColorSpecified as j, type RelationshipSpecification as k, type LikeC4ProjectStyleDefaults as l, type LikeC4ProjectStylesConfig as m, type LikeC4ProjectManualLayoutsConfig as n, type LikeC4Project as o, type AnyIncludePredicate as p, type AnyExcludePredicate as q, type AnyViewRuleStyle as r, isViewRuleGlobalStyle as s, type ViewRuleGlobalPredicateRef as t, isViewRuleGlobalPredicateRef as u, type AutoLayoutDirection as v, isAutoLayoutDirection as w, type ViewRuleAutoLayout as x, isViewRuleAutoLayout as y, type ViewAutoLayout as z };
