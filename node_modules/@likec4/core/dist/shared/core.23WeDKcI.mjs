import { b as t$d, n as n$e, c as t$j, t as t$k, d as t$l, e as t$m, i as isElementModel, f as isNestedElementOfDeployedInstanceModel, g as isDeployedInstanceModel, h as isDeploymentNodeModel, j as isDeploymentElementModel, k as buildElementNotations, L as LikeC4Model, a as t$q } from './core.h4TqqSC0.mjs';
import { t as t$b, a as t$c } from './core.BsSXS-_R.mjs';
import { t as t$f } from './core.CbT8JVYL.mjs';
import { c as commonHead, t as t$g, o as objectHash, b as t$n, a as compareRelations, S as Stack } from './core.DFCHU59b.mjs';
import { a as nonNullable, i as invariant, n as nonexhaustive } from './core.D4npX2q8.mjs';
import { G as Graph } from './core.DrUt0Lbi.mjs';
import { r as requireIterables, e as exact, t as t$o } from './core.M9ayqQZa.mjs';
import { r as requireIterator } from './core.BdPcbSkN.mjs';
import { g as getDefaultExportFromCjs } from './core.B85MJLTf.mjs';
import { n as n$d, t as t$e } from './core.OHD4KXm9.mjs';
import { e as e$4 } from './core.BKlholso.mjs';
import { f as flattenMarkdownOrString, i as isGroupElementKind, G as GroupElementKind, d as stepEdgeId } from './core.C_Ni6yHl.mjs';
import { b as isDescendantOf, f as sortParentsFirst, i as isAncestor, p as parentFqn, j as compareByFqnHierarchically, c as isNonEmptyArray, n as nameFromFqn, o as sortByFqnHierarchically, g as commonAncestor, a as ancestorsFqn, d as isSameHierarchy } from './core.6VsRBhGY.mjs';
import { d as difference, i as intersection, u as union, h as hasIntersection } from './core.CbsSAn1j.mjs';
import { e as e$8 } from './core.B9BjmjuH.mjs';
import { e as e$5, n as n$f, d as deploymentConnection, R as RelationshipsAccum, D as DeploymentConnectionModel } from './core.CHwVhuc9.mjs';
import { w as whereOperatorAsPredicate, m as isViewRuleStyle, v as t$h, l as isViewRulePredicate, a as _type, _ as _stage, u as e$b, t as isDynamicView, s as isDeploymentView, p as isElementView } from './core.DH7TXqXf.mjs';
import { e as e$6, a as iunique, i as iflat } from './core.C4x8aaWa.mjs';
import { e as e$7 } from './core.BoYfZOBm.mjs';
import { ModelFqnExpr, ModelRelationExpr, ModelExpression } from '../types/expression-model.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { preferSummary } from '../types/_aux.mjs';
import { a as t$i } from './core.DEieYfbG.mjs';
import { FqnExpr, RelationExpr } from '../types/expression.mjs';
import { f as findAscendingConnections, m as mergeConnections, d as differenceConnections, j as isNestedConnection, s as sortConnectionsByBoundaryHierarchy, o as findConnectionsBetween$3, p as findConnection$3, n as modelConnection, b as findDescendantConnections, a as findDeepestNestedConnection, i as isAnyInOut, k as isOutgoing, g as isIncoming, C as ConnectionModel } from './core.bKIs4oDO.mjs';
import { t as toSet, a as toArray, i as imap } from './core.C3JowhaZ.mjs';
import { D as DefaultMap } from './core.BbE4y-yl.mjs';
import { i as ifilter } from './core.DRJma0Ol.mjs';
import { C as Connection, c as customInspectSymbol } from './core.C0Ye2OCr.mjs';
import { i as isome } from './core.FZ305VYd.mjs';
import { i as isIterable, e as e$9 } from './core.RfnaEmgA.mjs';
import { j as e$a, c as isViewRuleAutoLayout, h as isViewRuleGroup, a as isViewRuleGlobalPredicateRef, i as isViewRuleGlobalStyle, e as isDynamicStepsParallel, f as isDynamicStepsSeries } from './core.BuQZczj6.mjs';
import { t as t$p } from './core.q10OP9oJ.mjs';

function e$3(e){return ()=>e}

function t$a(...t){return t$b(n$c,t)}function n$c(e,t){for(let[n,r]of e.entries())if(!t(r,n,e))return e.slice(n);return []}

const e$2=e=>Object.assign(e,{single:true});

function t$9(...t){return t$b(n$b,t)}const n$b=(e,t)=>{for(let n=e.length-1;n>=0;n--){let r=e[n];if(t(r,n,e))return r}};

function n$a(...n){return t$b(r$3,n,e$2(i$1))}const r$3=([e])=>e,i$1=()=>a,a=e=>({hasNext:true,next:e,done:true});

function t$8(...t){return t$b(n$9,t,r$2)}function n$9(e,t){return e.forEach(t),e}const r$2=e=>(t,n,r)=>(e(t,n,r),{done:false,hasNext:true,next:t});

function e$1(e){return typeof e==`boolean`}

function t$7(...t){return t$b(n$8,t)}function n$8(e,t){let n={};for(let[r,i]of e.entries()){let[a,o]=t(i,r,e);n[a]=o;}return n}

function n$7(...t){return t$b(r$1,t)}function r$1(e,n){if(!t$c(n,1))return {...e};if(!t$c(n,2)){let{[n[0]]:t,...r}=e;return r}let r={...e};for(let e of n)delete r[e];return r}

function t$6(...t){return t$b(n$6,t)}const n$6=e=>e.length===1?e[0]:void 0;

function t$5(...t){return t$b(n$5,t)}const n$5=(e,t)=>{let n=[[],[]];for(let[r,i]of e.entries())t(i,r,e)?n[0].push(i):n[1].push(i);return n};

function t$4(...t){return t$b(n$4,t)}function n$4(e,t){let n={};for(let r of t)r in e&&(n[r]=e[r]);return n}

function t$3(...t){return t$b(n$3,t)}function n$3(e,t){let n={};for(let[r,i]of Object.entries(e))t(i,r,e)&&(n[r]=i);return n}

function t$2(...t){return t$b(n$2,t)}const n$2=(e,t,n)=>e.reduce(t,n);

function t$1(...t){return t$b(n$1,t)}function n$1(e){return [...e].reverse()}

function n(...t){return t$b(r,t,i)}const r=(e,t)=>t<0?[]:e.slice(0,t);function i(e){if(e<=0)return n$d;let n=e;return e=>(--n,{done:n<=0,hasNext:true,next:e})}

function e(...e){return e.length===2?(n,...r)=>t(n,...e,...r):t(...e)}const t=(e,t,n,...r)=>t(e,...r)?typeof n==`function`?n(e,...r):n.onTrue(e,...r):typeof n==`function`?e:n.onFalse(e,...r);

function ancestorsOfNode(node, nodes) {
  const ancestors = [];
  let parentId = node.parent;
  while (parentId) {
    const parentNode = nonNullable(nodes.get(parentId), `Parent node ${parentId} not found`);
    ancestors.push(parentNode);
    parentId = parentNode.parent;
  }
  return ancestors;
}

function linkNodesWithEdges(nodesMap, edges) {
  for (const edge of edges) {
    const source = nodesMap.get(edge.source);
    const target = nodesMap.get(edge.target);
    invariant(source, `Source node ${edge.source} not found`);
    invariant(target, `Target node ${edge.target} not found`);
    source.outEdges.push(edge.id);
    target.inEdges.push(edge.id);
    const sourceAncestors = ancestorsOfNode(source, nodesMap);
    const targetAncestors = ancestorsOfNode(target, nodesMap);
    const hasAncestors = sourceAncestors.length > 0 && targetAncestors.length > 0;
    const edgeParent = hasAncestors ? t$d(
      commonHead(
        t$1(sourceAncestors),
        t$1(targetAncestors)
      )
    ) : null;
    edge.parent = edgeParent ? edgeParent.id : null;
    for (const sourceAncestor of sourceAncestors) {
      if (sourceAncestor === edgeParent) {
        break;
      }
      sourceAncestor.outEdges.push(edge.id);
    }
    for (const targetAncestor of targetAncestors) {
      if (targetAncestor === edgeParent) {
        break;
      }
      targetAncestor.inEdges.push(edge.id);
    }
  }
}

var topologicalSort$1 = {};

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */

var isGraph;
var hasRequiredIsGraph;

function requireIsGraph () {
	if (hasRequiredIsGraph) return isGraph;
	hasRequiredIsGraph = 1;
	/**
	 * Checking the value is a graphology instance.
	 *
	 * @param  {any}     value - Target value.
	 * @return {boolean}
	 */
	isGraph = function isGraph(value) {
	  return (
	    value !== null &&
	    typeof value === 'object' &&
	    typeof value.addUndirectedEdgeWithKey === 'function' &&
	    typeof value.dropNode === 'function' &&
	    typeof value.multi === 'boolean'
	  );
	};
	return isGraph;
}

/**
 * Mnemonist FixedDeque
 * =====================
 *
 * Fixed capacity double-ended queue implemented as ring deque.
 */

var fixedDeque;
var hasRequiredFixedDeque;

function requireFixedDeque () {
	if (hasRequiredFixedDeque) return fixedDeque;
	hasRequiredFixedDeque = 1;
	var iterables = /*@__PURE__*/ requireIterables(),
	    Iterator = requireIterator();

	/**
	 * FixedDeque.
	 *
	 * @constructor
	 */
	function FixedDeque(ArrayClass, capacity) {

	  if (arguments.length < 2)
	    throw new Error('mnemonist/fixed-deque: expecting an Array class and a capacity.');

	  if (typeof capacity !== 'number' || capacity <= 0)
	    throw new Error('mnemonist/fixed-deque: `capacity` should be a positive number.');

	  this.ArrayClass = ArrayClass;
	  this.capacity = capacity;
	  this.items = new ArrayClass(this.capacity);
	  this.clear();
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	FixedDeque.prototype.clear = function() {

	  // Properties
	  this.start = 0;
	  this.size = 0;
	};

	/**
	 * Method used to append a value to the deque.
	 *
	 * @param  {any}    item - Item to append.
	 * @return {number}      - Returns the new size of the deque.
	 */
	FixedDeque.prototype.push = function(item) {
	  if (this.size === this.capacity)
	    throw new Error('mnemonist/fixed-deque.push: deque capacity (' + this.capacity + ') exceeded!');

	  var index = this.start + this.size;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  this.items[index] = item;

	  return ++this.size;
	};

	/**
	 * Method used to prepend a value to the deque.
	 *
	 * @param  {any}    item - Item to prepend.
	 * @return {number}      - Returns the new size of the deque.
	 */
	FixedDeque.prototype.unshift = function(item) {
	  if (this.size === this.capacity)
	    throw new Error('mnemonist/fixed-deque.unshift: deque capacity (' + this.capacity + ') exceeded!');

	  var index = this.start - 1;

	  if (this.start === 0)
	    index = this.capacity - 1;

	  this.items[index] = item;
	  this.start = index;

	  return ++this.size;
	};

	/**
	 * Method used to pop the deque.
	 *
	 * @return {any} - Returns the popped item.
	 */
	FixedDeque.prototype.pop = function() {
	  if (this.size === 0)
	    return;

	  this.size--;

	  var index = this.start + this.size;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to shift the deque.
	 *
	 * @return {any} - Returns the shifted item.
	 */
	FixedDeque.prototype.shift = function() {
	  if (this.size === 0)
	    return;

	  var index = this.start;

	  this.size--;
	  this.start++;

	  if (this.start === this.capacity)
	    this.start = 0;

	  return this.items[index];
	};

	/**
	 * Method used to peek the first value of the deque.
	 *
	 * @return {any}
	 */
	FixedDeque.prototype.peekFirst = function() {
	  if (this.size === 0)
	    return;

	  return this.items[this.start];
	};

	/**
	 * Method used to peek the last value of the deque.
	 *
	 * @return {any}
	 */
	FixedDeque.prototype.peekLast = function() {
	  if (this.size === 0)
	    return;

	  var index = this.start + this.size - 1;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to get the desired value of the deque.
	 *
	 * @param  {number} index
	 * @return {any}
	 */
	FixedDeque.prototype.get = function(index) {
	  if (this.size === 0 || index >= this.capacity)
	    return;

	  index = this.start + index;

	  if (index >= this.capacity)
	    index -= this.capacity;

	  return this.items[index];
	};

	/**
	 * Method used to iterate over the deque.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	FixedDeque.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  var c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  while (j < l) {
	    callback.call(scope, this.items[i], j, this);
	    i++;
	    j++;

	    if (i === c)
	      i = 0;
	  }
	};

	/**
	 * Method used to convert the deque to a JavaScript array.
	 *
	 * @return {array}
	 */
	// TODO: optional array class as argument?
	FixedDeque.prototype.toArray = function() {

	  // Optimization
	  var offset = this.start + this.size;

	  if (offset < this.capacity)
	    return this.items.slice(this.start, offset);

	  var array = new this.ArrayClass(this.size),
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  while (j < l) {
	    array[j] = this.items[i];
	    i++;
	    j++;

	    if (i === c)
	      i = 0;
	  }

	  return array;
	};

	/**
	 * Method used to create an iterator over the deque's values.
	 *
	 * @return {Iterator}
	 */
	FixedDeque.prototype.values = function() {
	  var items = this.items,
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  return new Iterator(function() {
	    if (j >= l)
	      return {
	        done: true
	      };

	    var value = items[i];

	    i++;
	    j++;

	    if (i === c)
	      i = 0;

	    return {
	      value: value,
	      done: false
	    };
	  });
	};

	/**
	 * Method used to create an iterator over the deque's entries.
	 *
	 * @return {Iterator}
	 */
	FixedDeque.prototype.entries = function() {
	  var items = this.items,
	      c = this.capacity,
	      l = this.size,
	      i = this.start,
	      j = 0;

	  return new Iterator(function() {
	    if (j >= l)
	      return {
	        done: true
	      };

	    var value = items[i];

	    i++;

	    if (i === c)
	      i = 0;

	    return {
	      value: [j++, value],
	      done: false
	    };
	  });
	};

	/**
	 * Attaching the #.values method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;

	/**
	 * Convenience known methods.
	 */
	FixedDeque.prototype.inspect = function() {
	  var array = this.toArray();

	  array.type = this.ArrayClass.name;
	  array.capacity = this.capacity;

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(array, 'constructor', {
	    value: FixedDeque,
	    enumerable: false
	  });

	  return array;
	};

	if (typeof Symbol !== 'undefined')
	  FixedDeque.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedDeque.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a deque.
	 *
	 * @param  {Iterable} iterable   - Target iterable.
	 * @param  {function} ArrayClass - Array class to use.
	 * @param  {number}   capacity   - Desired capacity.
	 * @return {FiniteStack}
	 */
	FixedDeque.from = function(iterable, ArrayClass, capacity) {
	  if (arguments.length < 3) {
	    capacity = iterables.guessLength(iterable);

	    if (typeof capacity !== 'number')
	      throw new Error('mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.');
	  }

	  var deque = new FixedDeque(ArrayClass, capacity);

	  if (iterables.isArrayLike(iterable)) {
	    var i, l;

	    for (i = 0, l = iterable.length; i < l; i++)
	      deque.items[i] = iterable[i];

	    deque.size = l;

	    return deque;
	  }

	  iterables.forEach(iterable, function(value) {
	    deque.push(value);
	  });

	  return deque;
	};

	/**
	 * Exporting.
	 */
	fixedDeque = FixedDeque;
	return fixedDeque;
}

/**
 * Graphology Topological Sort
 * ============================
 *
 * Function performing topological sort over the given DAG using Kahn's
 * algorithm.
 *
 * This function also works on disconnected graphs.
 *
 * [Reference]:
 * https://en.wikipedia.org/wiki/Topological_sorting
 */

var hasRequiredTopologicalSort;

function requireTopologicalSort () {
	if (hasRequiredTopologicalSort) return topologicalSort$1;
	hasRequiredTopologicalSort = 1;
	const isGraph = requireIsGraph();
	const FixedDeque = /*@__PURE__*/ requireFixedDeque();

	function simpleInDegree(graph, node) {
	  let degree = 0;

	  graph.forEachInNeighbor(node, () => {
	    degree++;
	  });

	  return degree;
	}

	function forEachNodeInTopologicalOrder(graph, callback) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-sort: the given graph is not a valid graphology instance.'
	    );

	  // NOTE: falsely mixed graph representing directed graphs will work
	  if (graph.type === 'undirected' || graph.undirectedSize !== 0)
	    throw new Error(
	      'graphology-dag/topological-sort: cannot work if graph is not directed.'
	    );

	  if (graph.order === 0) return;

	  const queue = new FixedDeque(Array, graph.order);
	  const inDegrees = {};
	  let total = 0;

	  graph.forEachNode((node, attr) => {
	    const inDegree = graph.multi
	      ? simpleInDegree(graph, node)
	      : graph.inDegree(node);

	    if (inDegree === 0) {
	      queue.push([node, attr, 0]);
	    } else {
	      inDegrees[node] = inDegree;
	      total += inDegree;
	    }
	  });

	  let currentGeneration = 0;

	  function neighborCallback(neighbor, attr) {
	    const neighborInDegree = --inDegrees[neighbor];

	    total--;

	    if (neighborInDegree === 0)
	      queue.push([neighbor, attr, currentGeneration + 1]);

	    inDegrees[neighbor] = neighborInDegree;

	    // NOTE: key deletion is expensive in JS and in this case pointless so
	    // we just skip it for performance reasons
	  }

	  while (queue.size !== 0) {
	    const [node, attr, gen] = queue.shift();
	    currentGeneration = gen;

	    callback(node, attr, gen);

	    graph.forEachOutNeighbor(node, neighborCallback);
	  }

	  if (total !== 0)
	    throw new Error(
	      'graphology-dag/topological-sort: given graph is not acyclic.'
	    );
	}

	function topologicalSort(graph) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-sort: the given graph is not a valid graphology instance.'
	    );

	  const sortedNodes = new Array(graph.order);
	  let i = 0;

	  forEachNodeInTopologicalOrder(graph, node => {
	    sortedNodes[i++] = node;
	  });

	  return sortedNodes;
	}

	function forEachTopologicalGeneration(graph, callback) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-generations: the given graph is not a valid graphology instance.'
	    );

	  if (graph.order === 0) return;

	  let lastGenLevel = 0;
	  let lastGen = [];

	  forEachNodeInTopologicalOrder(graph, (node, _, gen) => {
	    if (gen > lastGenLevel) {
	      callback(lastGen);
	      lastGenLevel = gen;
	      lastGen = [];
	    }

	    lastGen.push(node);
	  });

	  callback(lastGen);
	}

	function topologicalGenerations(graph) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/topological-generations: the given graph is not a valid graphology instance.'
	    );

	  const generations = [];

	  forEachTopologicalGeneration(graph, generation => {
	    generations.push(generation);
	  });

	  return generations;
	}

	/**
	 * Exporting.
	 */
	topologicalSort$1.topologicalSort = topologicalSort;
	topologicalSort$1.forEachNodeInTopologicalOrder = forEachNodeInTopologicalOrder;
	topologicalSort$1.topologicalGenerations = topologicalGenerations;
	topologicalSort$1.forEachTopologicalGeneration = forEachTopologicalGeneration;
	return topologicalSort$1;
}

var topologicalSortExports = requireTopologicalSort();

/**
 * Graphology Cycle Creation Checker
 * ==================================
 *
 * Function returning whether adding the given directed edge to a DAG will
 * create a cycle.
 *
 * Note that this function requires the given graph to be a valid DAG forest
 * and will not check it beforehand for performance reasons.
 */

var willCreateCycle$1;
var hasRequiredWillCreateCycle;

function requireWillCreateCycle () {
	if (hasRequiredWillCreateCycle) return willCreateCycle$1;
	hasRequiredWillCreateCycle = 1;
	const isGraph = requireIsGraph();

	willCreateCycle$1 = function willCreateCycle(graph, source, target) {
	  if (!isGraph(graph))
	    throw new Error(
	      'graphology-dag/will-create-cycle: the given graph is not a valid graphology instance.'
	    );

	  source = '' + source;
	  target = '' + target;

	  // If the edge is a self loop, it will obviously add a cycle
	  if (source === target) return true;

	  // If any of the pointed nodes isn't in the graph yet,
	  // then no cycle can be created by adding this edge
	  if (!graph.hasNode(source) || !graph.hasNode(target)) return false;

	  // Early exit for existing edge or mutual one
	  if (graph.hasDirectedEdge(source, target)) return false;
	  if (graph.hasDirectedEdge(target, source)) return true;

	  // Else, we need to assess whether a directed path between target and source
	  // can be found. We will use DFS traversal because it is usually less
	  // costly than BFS (stack vs. queue).
	  const stack = graph.outNeighbors(target);

	  function push(neighbor) {
	    // NOTE: we don't check whether pushed neighbors have not been seen
	    // because this is not necessary in a DAG. This could result in
	    // undefined behavior for cyclic graphs, ranging from infinite loop to
	    // overkill memory usage.
	    stack.push(neighbor);
	  }

	  while (stack.length !== 0) {
	    const node = stack.pop();

	    if (node === source) return true;

	    graph.forEachOutNeighbor(node, push);
	  }

	  return false;
	};
	return willCreateCycle$1;
}

var willCreateCycleExports = requireWillCreateCycle();
const willCreateCycle = /*@__PURE__*/getDefaultExportFromCjs(willCreateCycleExports);

function ensureParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent = item.parent;
    if (parent) {
      const ancestors = [];
      while (parent) {
        const parentIndx = items.findIndex((i) => i.id === parent);
        if (parentIndx < 0) {
          break;
        }
        const [parentItem] = items.splice(parentIndx, 1);
        if (!parentItem) {
          throw new Error("Invalid state, should not happen");
        }
        ancestors.unshift(parentItem);
        parent = parentItem.parent;
      }
      result.push(...ancestors);
    }
    result.push(item);
  }
  return result;
}
function updateChildren(nodes) {
  nodes.forEach((parent) => {
    if (parent.children.length > 0) {
      parent.children = nodes.reduce((acc, n) => {
        if (n.parent === parent.id) {
          acc.push(n.id);
        }
        return acc;
      }, []);
    }
  });
  return nodes;
}
function topologicalSort(param) {
  let nodes = ensureParentsFirst([...param.nodes.values()]);
  let edges = [...param.edges];
  if (nodes.length < 2 || edges.length === 0) {
    return {
      nodes,
      edges
    };
  }
  const getNode = (id) => nonNullable(param.nodes.get(id));
  const g = new Graph({
    multi: true,
    allowSelfLoops: true,
    type: "directed"
  });
  const enrichedEdges = t$e(
    edges,
    t$f((edge) => {
      const source = getNode(edge.source), target = getNode(edge.target), parent = edge.parent ? getNode(edge.parent) : null;
      return {
        id: edge.id,
        edge,
        parent,
        source,
        target
      };
    })
  );
  const [edgesBetweenLeafs, edgesWithCompounds] = t$5(
    enrichedEdges,
    ({ source, target }) => source.children.length === 0 && target.children.length === 0
  );
  const sortedEdges = [];
  const addEdgeToGraph = (edge) => {
    g.mergeNode(edge.source);
    g.mergeNode(edge.target);
    sortedEdges.push(edge);
    if (!willCreateCycle(g, edge.source, edge.target)) {
      g.mergeDirectedEdge(edge.source, edge.target);
    }
  };
  for (const { edge, source, target } of edgesBetweenLeafs) {
    addEdgeToGraph(edge);
    if (target.parent && target.parent !== edge.parent) {
      t$e(
        ancestorsOfNode(target, param.nodes),
        t$g((ancestor) => ancestor.inEdges.includes(edge.id)),
        t$8((ancestor) => {
          g.mergeNode(ancestor.id);
          if (!willCreateCycle(g, edge.source, ancestor.id)) {
            g.mergeDirectedEdge(edge.source, ancestor.id);
          }
          if (!willCreateCycle(g, ancestor.id, edge.target)) {
            g.mergeDirectedEdge(ancestor.id, edge.target);
          }
        })
      );
    }
    if (source.parent) {
      const sourceParent = getNode(source.parent);
      g.mergeNode(sourceParent.id);
      if (!willCreateCycle(g, sourceParent.id, source.id)) {
        g.mergeDirectedEdge(sourceParent.id, source.id);
      }
      if (target.parent && target.parent !== source.parent) {
        if (!willCreateCycle(g, sourceParent.id, target.parent)) {
          g.mergeDirectedEdge(sourceParent.id, target.parent);
        }
      }
    }
  }
  for (const { edge } of edgesWithCompounds) {
    addEdgeToGraph(edge);
  }
  invariant(sortedEdges.length === edges.length, "Not all edges were added to the graph");
  const sortedIds = topologicalSortExports.topologicalSort(g);
  let sorted = [];
  let unsorted = nodes.slice();
  for (const sortedId of sortedIds) {
    const indx = unsorted.findIndex((n) => n.id === sortedId);
    invariant(indx >= 0, `Node "${sortedId}" not found`);
    sorted.push(...unsorted.splice(indx, 1));
  }
  if (unsorted.length > 0 && sorted.length > 0) {
    sorted = sorted.flatMap((node) => {
      if (unsorted.length === 0) {
        return node;
      }
      const wereBefore = nodes.slice(0, nodes.indexOf(node)).filter((n) => unsorted.includes(n));
      if (wereBefore.length > 0) {
        unsorted = unsorted.filter((n) => !wereBefore.includes(n));
        return [...wereBefore, node];
      }
      return node;
    });
  }
  sorted.push(...unsorted);
  return {
    nodes: updateChildren(
      ensureParentsFirst(sorted)
    ),
    edges: sortedEdges
  };
}

function calcViewLayoutHash(view) {
  const tohash = {
    id: view.id,
    __: view._type ?? "element",
    autoLayout: view.autoLayout,
    nodes: t$e(
      view.nodes,
      t$f((n) => ({
        id: n.id,
        icon: e$4(n.icon) && n.icon !== "none" ? "Y" : "N",
        title: n.title,
        description: flattenMarkdownOrString(n.description),
        technology: n.technology ?? null,
        shape: n.shape,
        size: n.style.size ?? null,
        textSize: n.style.textSize ?? null,
        padding: n.style.padding ?? null,
        children: n.children
      })),
      t$7(({ id, ...node }) => [id, node])
    ),
    edges: t$e(
      view.edges,
      t$f((e) => ({
        source: e.source,
        target: e.target,
        label: e.label,
        description: flattenMarkdownOrString(e.description),
        technology: e.technology ?? null,
        dir: e.dir,
        head: e.head,
        tail: e.tail,
        line: e.line
      })),
      t$7(({ source, target, ...edge }) => [`${source}:${target}`, edge])
    )
  };
  view.hash = objectHash(tohash);
  return view;
}

class AbstractMemory {
  constructor(state) {
    this.state = state;
  }
  /**
   * Provides access to context types
   * !IMPORTANT: Should not be called in runtime
   *
   * @example
   * ```ts
   *   type State = SomeMemory['Ctx']['MutableState']
   * ```
   */
  get Ctx() {
    throw new Error("Should not be called in runtime");
  }
  get elements() {
    return this.state.elements;
  }
  get explicits() {
    return this.state.explicits;
  }
  get final() {
    return this.state.final;
  }
  get connections() {
    return this.state.connections;
  }
  isEmpty() {
    return this.elements.size === 0 && this.connections.length === 0 && this.explicits.size === 0 && this.final.size === 0;
  }
}

class AbstractStageExclude {
  constructor(memory, expression) {
    this.memory = memory;
    this.expression = expression;
  }
  // Removed elements
  excluded = {
    elements: /* @__PURE__ */ new Set(),
    connections: []
  };
  markedToMoveExplicitToImplicit = false;
  _removeElement(element) {
    this.excluded.elements.add(element);
  }
  exclude(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._removeElement(el);
      }
      return this;
    }
    this._removeElement(element);
    return this;
  }
  _removeConnection(connection) {
    this.excluded.connections.push(connection);
  }
  /**
   * Excludes from the memory relationships from given connections (still connection may be included, but without given relationships)
   * @param moveExplicitToImplicit - if true, disconnected explicit elements will be moved to implicit
   * @default false
   */
  excludeConnections(connection, moveExplicitToImplicit) {
    if (e$1(moveExplicitToImplicit)) {
      invariant(!this.markedToMoveExplicitToImplicit, "Already marked to move explicits");
      this.markedToMoveExplicitToImplicit = moveExplicitToImplicit;
    }
    if (isIterable(connection)) {
      for (const c of connection) {
        this._removeConnection(c);
      }
      return this;
    }
    this._removeConnection(connection);
    return this;
  }
  isDirty() {
    return this.excluded.elements.size > 0 || this.excluded.connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Determines whether disconnected explicits should become implicits.
   * By default moves all disconnected explicits to implicits, if there were operation to exclude elements.
   *
   * Override this method to change the behavior.
   */
  filterForMoveToImplicits(disconnectedExplicits) {
    if (this.markedToMoveExplicitToImplicit || this.excluded.elements.size > 0) {
      return disconnectedExplicits;
    }
    return /* @__PURE__ */ new Set();
  }
  // Check if Leaf EXPLICIT elements are becoming IMPLICIT
  // (it means that they are not connected anymore)
  moveDisconnectedExplicitsToImplicits(state) {
    let disconnected = difference(
      new Set(this.memory.connections.flatMap((c) => [c.source, c.target])),
      new Set(state.connections.flatMap((c) => [c.source, c.target]))
    );
    disconnected = intersection(
      disconnected,
      state.elements
    );
    disconnected = t$e(
      disconnected,
      ifilter((el) => {
        return state.explicits.has(el) && !isome(state.final, isDescendantOf(el));
      }),
      toSet()
    );
    if (disconnected.size > 0) {
      disconnected = this.filterForMoveToImplicits(disconnected);
      state.explicits = difference(state.explicits, disconnected);
      state.final = difference(state.final, disconnected);
    }
    return state;
  }
  removeElements(state) {
    state.elements = difference(state.elements, this.excluded.elements);
    state.explicits = difference(state.explicits, this.excluded.elements);
    state.final = difference(state.final, this.excluded.elements);
    return state;
  }
  removeConnections(state) {
    const excludedMap = this.excluded.connections.reduce((acc, c) => {
      const existing = acc.get(c.id);
      if (existing) {
        acc.set(c.id, existing.mergeWith(c));
      } else {
        acc.set(c.id, c);
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    let disconnected = /* @__PURE__ */ new Set();
    state.connections = state.connections.reduce((acc, c) => {
      const excluded = excludedMap.get(c.id);
      if (excluded) {
        disconnected.add(c.source);
        disconnected.add(c.target);
        const diff = c.difference(excluded);
        if (diff.nonEmpty()) {
          acc.push(diff);
        }
      } else {
        acc.push(c);
      }
      return acc;
    }, []);
    for (const stillExists of state.connections) {
      disconnected.delete(stillExists.source);
      disconnected.delete(stillExists.target);
      if (stillExists.boundary && state.elements.has(stillExists.boundary)) {
        disconnected.delete(stillExists.boundary);
      }
    }
    if (disconnected.size === 0) {
      return state;
    }
    disconnected = difference(disconnected, state.explicits);
    state.final = difference(state.final, disconnected);
    return state;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    invariant(difference(state.explicits, state.elements).size === 0, "Explicits must be subset of elements");
    invariant(difference(state.final, state.elements).size === 0, "Final elements must be subset of elements");
    return state;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    if (this.excluded.elements.size > 0) {
      const excludedConnections = state.connections.filter((c) => this.excluded.elements.has(c.source) || this.excluded.elements.has(c.target)).flatMap((c) => [
        c,
        ...findAscendingConnections(state.connections, c).map((asc) => asc.intersect(c))
      ]).filter((asc) => asc.nonEmpty());
      this.excludeConnections(excludedConnections);
    }
    if (this.excluded.connections.length > 0) {
      state = this.removeConnections(state);
    }
    if (this.excluded.elements.size > 0) {
      state = this.removeElements(state);
    }
    return this.memory.update(this.postcommit(state));
  }
}

class AbstractStageInclude {
  constructor(memory, expression) {
    this.memory = memory;
    this.expression = expression;
  }
  // New elements
  explicits = /* @__PURE__ */ new Set();
  implicits = /* @__PURE__ */ new Set();
  // Ordered Set of explicit and implicit elements
  _ordered = /* @__PURE__ */ new Set();
  _connections = [];
  get elements() {
    return this.explicits;
  }
  /**
   * Connections from this stage
   */
  get connections() {
    return this._connections;
  }
  mergedConnections() {
    return mergeConnections([
      ...this.memory.connections,
      ...this._connections
    ]);
  }
  connectWithExisting(_element, _direction) {
    throw new Error("Method not implements, depends on the model");
  }
  /**
   * Possible to override
   */
  _addExplicit(elements) {
    this._ordered.add(elements);
    this.explicits.add(elements);
    this.implicits.delete(elements);
  }
  addExplicit(element) {
    if (!element) {
      return this;
    }
    if (isIterable(element)) {
      for (const el of element) {
        this._addExplicit(el);
      }
      return this;
    }
    this._addExplicit(element);
    return this;
  }
  /**
   * Possible to override
   */
  _addImplicit(elements) {
    if (this.explicits.has(elements)) {
      return;
    }
    this._ordered.add(elements);
    this.implicits.add(elements);
  }
  addImplicit(elements) {
    if (!elements) {
      return this;
    }
    if (isIterable(elements)) {
      for (const el of elements) {
        this._addImplicit(el);
      }
      return this;
    }
    this._addImplicit(elements);
    return this;
  }
  /**
   * Possible to override
   */
  _addConnection(connection) {
    this._connections.push(connection);
    this._addImplicit(connection.source);
    this._addImplicit(connection.target);
  }
  addConnections(connection) {
    if (isIterable(connection)) {
      for (const c of connection) {
        this._addConnection(c);
      }
      return this;
    }
    this._addConnection(connection);
    return this;
  }
  isDirty() {
    return this.explicits.size > 0 || this.implicits.size > 0 || this._connections.length > 0;
  }
  isEmpty() {
    return !this.isDirty();
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    return state;
  }
  /**
   * Postcommit hook
   */
  postcommit(state) {
    return state;
  }
  processConnections(connections) {
    return connections;
  }
  commit() {
    let state = this.precommit(this.memory.mutableState());
    let fromConnections = /* @__PURE__ */ new Set();
    if (this._connections.length > 0) {
      const [fromKnown, rest] = t$5(
        this._connections,
        (c) => state.final.has(c.source)
      );
      state.connections = this.processConnections(
        mergeConnections([
          ...state.connections,
          ...fromKnown,
          ...rest
        ])
      );
      fromConnections = new Set(state.connections.flatMap((c) => [c.source, c.target]));
    }
    state.elements = union(
      state.elements,
      this._ordered,
      this.explicits,
      fromConnections,
      this.implicits
    );
    state.explicits = intersection(
      state.elements,
      union(
        state.explicits,
        this.explicits
      )
    );
    state.final = intersection(
      state.elements,
      union(
        state.final,
        this.explicits,
        fromConnections
      )
    );
    return this.memory.update(this.postcommit(state));
  }
}

function treeFromMemoryState(memory, filter = "final") {
  const sorted = sortParentsFirst(toArray(filter === "final" ? memory.final : memory.elements));
  const connected = new Set(memory.connections.flatMap((c) => [c.source, c.target]));
  const root = new Set(sorted);
  const parents = new DefaultMap(() => null);
  const children = sorted.reduce((acc, parent, index, all) => {
    acc.set(
      parent,
      all.slice(index + 1).filter((e) => isAncestor(parent, e)).map((e) => {
        root.delete(e);
        return e;
      }).reduce((acc2, el) => {
        if (!acc2.some((e) => isAncestor(e, el))) {
          acc2.push(el);
          parents.set(el, parent);
        }
        return acc2;
      }, [])
    );
    return acc;
  }, new DefaultMap(() => []));
  return {
    root,
    connected,
    hasInOut: (el) => memory.connections.some(Connection.isAnyInOut(el.id)),
    parent: (el) => parents.get(el),
    children: (el) => children.get(el)
  };
}

let StageExclude$1 = class StageExclude extends AbstractStageExclude {
};

function elementExprToPredicate(target) {
  if (ModelFqnExpr.isCustom(target)) {
    return elementExprToPredicate(target.custom.expr);
  }
  if (ModelFqnExpr.isWhere(target)) {
    const predicate = elementExprToPredicate(target.where.expr);
    const where = whereOperatorAsPredicate(target.where.condition);
    return (n) => predicate(n) && where(n);
  }
  if (ModelFqnExpr.isElementKindExpr(target)) {
    return target.isEqual ? (n) => n.kind === target.elementKind : (n) => n.kind !== target.elementKind;
  }
  if (ModelFqnExpr.isElementTagExpr(target)) {
    return target.isEqual ? ({ tags }) => tags.includes(target.elementTag) : ({ tags }) => !tags.includes(target.elementTag);
  }
  if (ModelFqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (ModelFqnExpr.isModelRef(target)) {
    const fqn = FqnRef.flatten(target.ref);
    if (target.selector === "expanded") {
      return (n) => {
        return n.id === fqn || parentFqn(n.id) === fqn;
      };
    }
    if (target.selector === "descendants" || target.selector === "children") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        return n.id.startsWith(fqnWithDot);
      };
    }
    return (n) => {
      return n.id === fqn;
    };
  }
  nonexhaustive(target);
}

function applyViewRuleStyle(rule, predicates, nodes) {
  const { shape, color, icon, ...rest } = rule.style;
  const nonEmptyStyle = !e$5(rest);
  t$e(
    nodes,
    n$e(e$7(isGroupElementKind)),
    n$e(t$h(predicates)),
    t$8((n) => {
      n.shape = shape ?? n.shape;
      n.color = color ?? n.color;
      if (e$6(icon)) {
        n.icon = icon;
      }
      if (e$6(rule.notation)) {
        n.notation = rule.notation;
      }
      if (nonEmptyStyle) {
        n.style = {
          ...n.style,
          ...rest
        };
      }
    })
  );
}
function applyViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(elementExprToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}

function updateDepthOfAncestors(node, nodes) {
  let parentNd;
  while (!!node.parent && (parentNd = nodes.get(node.parent))) {
    const depth = parentNd.depth ?? 1;
    parentNd.depth = Math.max(depth, (node.depth ?? 0) + 1);
    if (parentNd.depth === depth) {
      break;
    }
    node = parentNd;
  }
}
function elementModelToNodeSource(el) {
  const {
    id,
    title,
    ...rest
  } = n$7(el.$element, ["summary", "description", "metadata", "style", "tags"]);
  const { color, icon, shape, ...style } = el.style;
  return exact({
    id,
    title,
    modelRef: id,
    shape,
    color,
    icon,
    style,
    description: preferSummary(el.$element),
    tags: [...el.tags],
    ...rest
  });
}
function buildComputedNodes({ defaults }, elements, groups) {
  const nodesMap = /* @__PURE__ */ new Map();
  const elementToGroup = /* @__PURE__ */ new Map();
  groups?.forEach(({ id, parent, viewRule, elements: elements2 }) => {
    if (parent) {
      nonNullable(nodesMap.get(parent), `Parent group node ${parent} not found`).children.push(id);
    }
    nodesMap.set(id, {
      id,
      parent,
      kind: GroupElementKind,
      title: viewRule.title ?? "",
      color: viewRule.color ?? defaults.group?.color ?? defaults.color,
      shape: "rectangle",
      children: [],
      inEdges: [],
      outEdges: [],
      level: 0,
      depth: 0,
      tags: [],
      style: exact({
        border: viewRule.border ?? defaults.group?.border ?? defaults.border,
        opacity: viewRule.opacity ?? defaults.group?.opacity ?? defaults.opacity,
        size: viewRule.size,
        multiple: viewRule.multiple,
        padding: viewRule.padding,
        textSize: viewRule.textSize
      })
    });
    for (const e of elements2) {
      elementToGroup.set(e.id, id);
    }
  });
  Array.from(elements).sort(compareByFqnHierarchically).forEach(({ id, ...el }) => {
    let parent = parentFqn(id);
    let level = 0;
    let parentNd;
    while (parent) {
      parentNd = nodesMap.get(parent);
      if (parentNd) {
        break;
      }
      parent = parentFqn(parent);
    }
    const fqn = el.modelRef ?? id;
    if (!parentNd && elementToGroup.has(fqn)) {
      const parentGroupId = nonNullable(elementToGroup.get(fqn));
      parentNd = nodesMap.get(parentGroupId);
      parent = parentGroupId;
    }
    if (parentNd) {
      if (parentNd.children.length == 0) {
        parentNd.depth = 1;
        updateDepthOfAncestors(parentNd, nodesMap);
      }
      parentNd.children.push(id);
      level = parentNd.level + 1;
    }
    const node = exact({
      id,
      parent,
      level,
      children: [],
      inEdges: [],
      outEdges: [],
      ...el
    });
    nodesMap.set(id, node);
  });
  const orderedMap = /* @__PURE__ */ new Map();
  groups?.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  elements.forEach(({ id }) => {
    orderedMap.set(id, nonNullable(nodesMap.get(id)));
  });
  return orderedMap;
}

function pickRelationshipProps(relation) {
  const {
    title,
    description = null,
    technology = null,
    kind = null,
    color = null,
    line = null,
    head = null,
    tail = null,
    navigateTo = null
  } = relation;
  return {
    // Pick description only if title is present
    ...title && {
      title,
      description
    },
    technology,
    kind,
    color,
    line,
    head,
    tail,
    navigateTo
  };
}
function mergePropsFromRelationships(relations, prefer) {
  const allprops = t$e(
    relations,
    t$2(
      (acc, r) => {
        if (e$4(r.title) && !acc.title.includes(r.title)) {
          acc.title.push(r.title);
        }
        if (e$4(r.description) && !acc.description.some(t$i(r.description))) {
          acc.description.push(r.description);
        }
        if (e$4(r.technology) && !acc.technology.includes(r.technology)) {
          acc.technology.push(r.technology);
        }
        if (e$4(r.kind) && !acc.kind.includes(r.kind)) {
          acc.kind.push(r.kind);
        }
        if (e$4(r.color) && !acc.color.includes(r.color)) {
          acc.color.push(r.color);
        }
        if (e$4(r.line) && !acc.line.includes(r.line)) {
          acc.line.push(r.line);
        }
        if (e$4(r.head) && !acc.head.includes(r.head)) {
          acc.head.push(r.head);
        }
        if (e$4(r.tail) && !acc.tail.includes(r.tail)) {
          acc.tail.push(r.tail);
        }
        if (e$4(r.navigateTo) && !acc.navigateTo.includes(r.navigateTo)) {
          acc.navigateTo.push(r.navigateTo);
        }
        if (r.tags) {
          acc.tags.push(...r.tags);
        }
        return acc;
      },
      {
        title: [],
        description: [],
        technology: [],
        kind: [],
        head: [],
        tail: [],
        color: [],
        tags: [],
        line: [],
        navigateTo: []
      }
    )
  );
  let technology = t$6(allprops.technology);
  let title = t$6(allprops.title) ?? (allprops.title.length > 1 ? "[...]" : null);
  const tags = n$f(allprops.tags);
  let merged = exact({
    // If there is no title, but there is technology, use technology as title
    title: title ?? (technology ? `[${technology}]` : null),
    description: t$6(allprops.description),
    technology,
    kind: t$6(allprops.kind),
    head: t$6(allprops.head),
    tail: t$6(allprops.tail),
    color: t$6(allprops.color),
    line: t$6(allprops.line),
    navigateTo: t$6(allprops.navigateTo),
    ...isNonEmptyArray(tags) && { tags }
  });
  if (prefer) {
    return {
      ...merged,
      ...t$3(pickRelationshipProps(prefer), e$4)
    };
  }
  return merged;
}

const { findConnection: findConnection$2, findConnectionsBetween: findConnectionsBetween$2, findConnectionsWithin: findConnectionsWithin$1 } = deploymentConnection;
function resolveElements$1(model, expr) {
  const ref = model.element(expr.ref.deployment);
  if (ref.isDeploymentNode()) {
    if (expr.selector === "children") {
      return [...ref.children()];
    }
    if (expr.selector === "expanded") {
      return [ref, ...ref.children()];
    }
    if (expr.selector === "descendants") {
      return [...ref.descendants()];
    }
  }
  return [ref];
}
function resolveModelElements(model, expr) {
  const ref = model.$model.element(expr.ref.model);
  if (expr.selector === "children") {
    return [...ref.children()];
  }
  if (expr.selector === "expanded") {
    return [ref, ...ref.children()];
  }
  if (expr.selector === "descendants") {
    return [...ref.descendants()];
  }
  return [ref];
}
function deploymentExpressionToPredicate(target) {
  if (FqnExpr.isWildcard(target)) {
    return () => true;
  }
  if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
    throw new Error("element kind and tag expressions are not supported in deployment view rules");
  }
  if (FqnExpr.isDeploymentRef(target)) {
    const fqn = target.ref.deployment;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n) => n.id === fqn || n.id.startsWith(fqnWithDot);
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n) => n.id.startsWith(fqnWithDot);
    }
    if (target.selector === "children") {
      return (n) => parentFqn(n.id) === fqn;
    }
    return (n) => n.id === fqn;
  }
  if (FqnExpr.isModelRef(target)) {
    const fqn = target.ref.model;
    if (target.selector === "expanded") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        const m = n.modelRef ?? null;
        if (!m) {
          return true;
        }
        return m === fqn || m.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "descendants") {
      const fqnWithDot = fqn + ".";
      return (n) => {
        const m = n.modelRef ?? null;
        if (!m) {
          return true;
        }
        return m.startsWith(fqnWithDot);
      };
    }
    if (target.selector === "children") {
      return (n) => {
        const m = n.modelRef ?? null;
        if (!m) {
          return true;
        }
        return parentFqn(m) === fqn;
      };
    }
    return (n) => {
      const m = n.modelRef ?? null;
      if (!m) {
        return true;
      }
      return m === fqn;
    };
  }
  nonexhaustive(target);
}
function instanceSummary(model) {
  return preferSummary(model.$instance) ?? preferSummary(model.element.$element);
}
function toNodeSource(el) {
  if (el.isDeploymentNode()) {
    const onlyOneInstance = el.onlyOneInstance();
    let {
      title,
      id,
      description: description2,
      summary,
      metadata: _metadata,
      // omit
      style: {
        icon: icon2,
        shape: shape2,
        color: color2
      },
      element: _element,
      // omit
      tags: _tags,
      // omit
      ...$node
    } = el.$node;
    let tags = [...el.tags];
    summary ??= description2;
    if (onlyOneInstance) {
      tags = n$f([...tags, ...onlyOneInstance.tags]);
      if (title === nameFromFqn(el.id)) {
        title = onlyOneInstance.title;
      }
      icon2 ??= onlyOneInstance.style.icon;
      color2 ??= onlyOneInstance.style.color;
      shape2 ??= onlyOneInstance.style.shape;
      summary ??= instanceSummary(onlyOneInstance);
    }
    return exact({
      id,
      deploymentRef: id,
      title,
      ...$node,
      color: color2 ?? el.color,
      shape: shape2 ?? el.shape,
      ...onlyOneInstance && {
        modelRef: onlyOneInstance.element.id
      },
      icon: icon2,
      description: summary,
      tags,
      style: n$7(el.style, ["icon", "shape", "color"])
    });
  }
  invariant(el.isInstance(), "Expected Instance");
  const instance = el.$instance;
  const element = el.element;
  const { icon, color, shape, ...style } = el.style;
  const links = [
    ...element.links,
    ...instance.links ?? []
  ];
  const notation = instance.notation ?? element.$element.notation;
  const description = instanceSummary(el);
  const technology = el.technology ?? void 0;
  return exact({
    id: el.id,
    kind: "instance",
    title: el.title,
    description,
    technology,
    tags: [...el.tags],
    links: t$c(links, 1) ? links : void 0,
    icon,
    color,
    shape,
    style,
    deploymentRef: instance.id,
    modelRef: element.id,
    notation
  });
}
function toComputedEdges$1(connections) {
  return connections.reduce((acc, e) => {
    const relations = [
      ...e.relations.model,
      ...e.relations.deployment
    ];
    invariant(t$c(relations, 1), "Edge must have at least one relation");
    const defaults = e.source.$model.$styles.defaults;
    const source = e.source.id;
    const target = e.target.id;
    const {
      title,
      color = defaults.relationship.color,
      line = defaults.relationship.line,
      head = defaults.relationship.arrow,
      ...props
    } = mergePropsFromRelationships(relations.map((r) => r.$relationship));
    const edge = exact({
      id: e.id,
      parent: e.boundary?.id ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r) => r.id),
      color,
      line,
      head,
      ...props
    });
    const existing = acc.find((e2) => e2.source === target && e2.target === source);
    if (existing && edge.label === existing.label) {
      existing.dir = "both";
      const head2 = existing.head ?? edge.head ?? e.source.$model.$styles.defaults.relationship.arrow;
      existing.head ??= head2;
      existing.tail ??= head2;
      if (edge.color) {
        existing.color ??= edge.color;
      }
      if (edge.line) {
        existing.line ??= edge.line;
      }
      return acc;
    }
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes$1(model, memory) {
  return buildComputedNodes(model.$styles, [...memory.final].map(toNodeSource));
}
function applyDeploymentViewRuleStyles(rules, nodes) {
  for (const rule of rules) {
    if (!isViewRuleStyle(rule) || rule.targets.length === 0) {
      continue;
    }
    const predicates = rule.targets.map(deploymentExpressionToPredicate);
    applyViewRuleStyle(rule, predicates, nodes);
  }
  return nodes;
}

function findCrossBoundarySameSourceOrTarget(connections) {
  const groupedByRelation = new DefaultMap(() => []);
  for (const conn of connections) {
    for (const relation of conn.relations.model) {
      groupedByRelation.get(relation).push(conn);
    }
  }
  const excludedRelations = new DefaultMap(() => /* @__PURE__ */ new Set());
  for (const [relation, sameRelationGroup] of groupedByRelation) {
    if (!t$c(sameRelationGroup, 2)) {
      continue;
    }
    t$e(
      sameRelationGroup,
      t$m((conn) => [
        { group: `$source-${conn.source.id}`, conn },
        { group: `$target-${conn.target.id}`, conn }
      ]),
      t$l(e$8("group")),
      t$k(),
      n$e(t$c(2)),
      t$8(
        // In each group, sort by hierarchy, first are deepest
        t$j(
          t$f(e$8("conn")),
          sortConnectionsByBoundaryHierarchy("desc"),
          // Drop first, as it is the deepest
          // Drop if boundary is same as previous
          t$a((conn, i, all) => i === 0 || conn.boundary === all[i - 1].boundary),
          // Drop relations from boundaries above
          t$8((conn) => {
            excludedRelations.get(conn).add(relation);
          })
        )
      )
    );
  }
  return excludedRelations;
}
function findCrossBoundaryConnections(connections) {
  connections = mergeConnections(connections);
  const excludedRelations = findCrossBoundarySameSourceOrTarget(connections);
  for (const c of connections) {
    const { source, target } = c;
    const connectionModelRelations = c.relations.model;
    if (source.isDeploymentNode() !== target.isDeploymentNode()) {
      const node = source.isDeploymentNode() ? source : c.target;
      invariant(node.isDeploymentNode());
      const nodeInternals = node.internalModelRelationships();
      const toExclude = intersection(
        connectionModelRelations,
        nodeInternals
      );
      for (const relation of toExclude) {
        excludedRelations.get(c).add(relation);
      }
      continue;
    }
    if (source.isDeploymentNode() && target.isDeploymentNode()) {
      const toExclude = union(
        // Exclude node internals (otherwise thay are cross-boundary)
        intersection(
          c.relations.model,
          source.internalModelRelationships()
        ),
        intersection(
          c.relations.model,
          target.internalModelRelationships()
        )
      );
      for (const relation of toExclude) {
        excludedRelations.get(c).add(relation);
      }
    }
  }
  return t$e(
    excludedRelations.entries(),
    imap(
      ([c, excluded]) => c.update({
        model: excluded,
        deployment: null
      })
    ),
    toArray()
  );
}
function cleanCrossBoundary(connections) {
  return differenceConnections(
    connections,
    findCrossBoundaryConnections(connections)
  );
}
function findRedundantConnections$1(connections) {
  return t$e(
    connections,
    mergeConnections,
    t$2((redundants, connection) => {
      const { source, target, relations } = connection;
      if (source.isInstance() && target.isInstance()) {
        return redundants;
      }
      let redundantAccum = RelationshipsAccum.empty();
      if (source.isDeploymentNode() && target.isDeploymentNode()) {
        const [reversed] = findConnection$2(target, source, "directed");
        if (reversed) {
          redundantAccum = relations.intersect(reversed.relations);
        }
      }
      for (const c of connections) {
        if (isNestedConnection(c, connection)) {
          redundantAccum = redundantAccum.union(
            relations.intersect(c.relations)
          );
        }
      }
      if (redundantAccum.nonEmpty) {
        redundants.push(
          new DeploymentConnectionModel(
            source,
            target,
            redundantAccum
          )
        );
      }
      return redundants;
    }, [])
  );
}
function cleanRedundantRelationships(connections) {
  return differenceConnections(
    connections,
    findRedundantConnections$1(connections)
  );
}

let StageInclude$1 = class StageInclude extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection$2(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween$2(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween$2(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween$2(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  processConnections(connections) {
    const clean = t$e(
      connections,
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    t$e(
      clean,
      // Process only connection from this stage
      // filter(c => this._connections.some(c2 => c2.id === c.id)),
      t$8(({ source, target, boundary }) => {
        t$e(
          t$n(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          t$a(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          n(1),
          t$8(([sourceAncestor, targetAncestor]) => {
            if (source === sourceAncestor && target === targetAncestor) {
              this.addImplicit(boundary);
              return;
            }
            if (sourceAncestor !== source && sourceAncestor.isDeploymentNode() && !sourceAncestor.onlyOneInstance()) {
              this.addImplicit(sourceAncestor);
            }
            if (targetAncestor !== target && targetAncestor.isDeploymentNode() && !targetAncestor.onlyOneInstance()) {
              this.addImplicit(targetAncestor);
            }
          })
        );
      })
    );
    return clean;
  }
};

let Memory$1 = class Memory extends AbstractMemory {
  static empty() {
    return new Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: []
    });
  }
  stageInclude(expr) {
    return new StageInclude$1(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude$1(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections]
    };
  }
  update(newstate) {
    return new Memory({
      ...this.state,
      ...newstate
    });
  }
  equals(other) {
    return other instanceof Memory && t$i(this.state, other.state);
  }
  diff(state) {
    return {
      added: {
        elements: toArray(difference(state.elements, this.elements)),
        explicits: toArray(difference(state.explicits, this.explicits)),
        final: toArray(difference(state.final, this.final)),
        connections: toArray(differenceConnections(state.connections, this.connections))
      },
      removed: {
        elements: toArray(difference(this.elements, state.elements)),
        explicits: toArray(difference(this.explicits, state.explicits)),
        final: toArray(difference(this.final, state.final)),
        connections: differenceConnections(this.connections, state.connections)
      }
    };
  }
  toString() {
    return [
      "final:",
      ...[...this.final].map((e) => "  " + e.id),
      "connections:",
      ...this.connections.map((c) => "  " + c.expression)
    ].join("\n");
  }
  [customInspectSymbol](_depth, _inspectOptions, _inspect) {
    const asString = this.toString();
    return asString;
  }
};

const WhereDeploymentRefPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};

const IncomingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.incoming)) {
      for (const source of sources) {
        if (source.allOutgoing.isEmpty) {
          continue;
        }
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = applyPredicate(findConnectionsBetween$2(source, targets2, "directed"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.incoming), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.incoming);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween$2(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.incoming) || FqnExpr.isElementKindExpr(expr.incoming)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.incoming)) {
      const excludedRelations = resolveAllImcomingRelations(model, expr.incoming);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.incoming)) {
      return stage;
    }
    const isIncoming = filterIncomingConnections(resolveElements$1(model, expr.incoming));
    const toExclude = t$e(
      memory.connections,
      n$e(isIncoming),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterIncomingConnections(targets) {
  return t$h(
    targets.map((target) => {
      const satisfies = (el) => el === target || isAncestor(target, el);
      return (connection) => {
        return !satisfies(connection.source) && satisfies(connection.target);
      };
    })
  );
}
function resolveAllImcomingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e) => [...e.allIncoming]));
}

const OutgoingRelationPredicate = {
  include: ({ expr, model, memory, stage, where }) => {
    const targets = [...memory.elements];
    if (FqnExpr.isWildcard(expr.outgoing)) {
      for (const target of targets) {
        if (target.allIncoming.isEmpty) {
          continue;
        }
        for (const source of resolveAscendingSiblings(target)) {
          const toInclude = applyPredicate(findConnection$2(source, target, "directed"), where);
          stage.addConnections(toInclude);
        }
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.outgoing), "Only deployment refs are supported in include");
    const sources = resolveElements$1(model, expr.outgoing);
    for (const source of sources) {
      const toInclude = applyPredicate(findConnectionsBetween$2(source, targets, "directed"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.outgoing) || FqnExpr.isElementKindExpr(expr.outgoing)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.outgoing)) {
      const excludedRelations = resolveAllOutgoingRelations(model, expr.outgoing);
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.outgoing)) {
      return stage;
    }
    const isOutgoing = filterOutgoingConnections(resolveElements$1(model, expr.outgoing));
    const toExclude = t$e(
      memory.connections,
      n$e(isOutgoing),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};
function filterOutgoingConnections(sources) {
  return t$h(
    sources.map((source) => {
      const satisfies = (el) => el === source || isAncestor(source, el);
      return (connection) => {
        return satisfies(connection.source) && !satisfies(connection.target);
      };
    })
  );
}
function resolveAllOutgoingRelations(model, moodelRef) {
  const targets = resolveModelElements(model, moodelRef);
  return new Set(targets.flatMap((e) => [...e.allOutgoing]));
}

const resolveAscendingSiblings = (element) => {
  const siblings = /* @__PURE__ */ new Set();
  for (let sibling of element.descendingSiblings()) {
    siblings.add(sibling);
  }
  return siblings;
};
const DirectRelationPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, model, stage, where }) => {
    if (FqnExpr.isElementTagExpr(source) || FqnExpr.isElementKindExpr(source)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    if (FqnExpr.isElementTagExpr(target) || FqnExpr.isElementKindExpr(target)) {
      throw new Error("element kind and tag expressions are not supported in include");
    }
    invariant(!FqnExpr.isModelRef(source), "Invalid source model ref in direct relation");
    invariant(!FqnExpr.isModelRef(target), "Invalid target model ref in direct relation");
    const sourceIsWildcard = FqnExpr.isWildcard(source);
    const targetIsWildcard = FqnExpr.isWildcard(target);
    const dir = isBidirectional ? "both" : "directed";
    let connections;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections = t$e(
          findConnectionsWithin$1(model.instances()),
          applyPredicate(where),
          t$f((c) => {
            stage.addImplicit(c.boundary);
            return c;
          })
        );
        break;
      }
      // source -> *; source <-> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements$1(model, source);
        const isSource = filterOutgoingConnections(sources);
        let postFilter = isSource;
        if (isBidirectional) {
          const isTarget = filterIncomingConnections(sources);
          postFilter = (c) => isSource(c) !== isTarget(c);
        }
        connections = t$e(
          sources,
          t$m((source2) => {
            const targets = resolveAscendingSiblings(source2);
            return findConnectionsBetween$2(source2, targets, dir);
          }),
          n$e(postFilter),
          applyPredicate(where)
        );
        break;
      }
      // * -> target; * <-> target
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements$1(model, target);
        const isTarget = filterIncomingConnections(targets);
        let postFilter = isTarget;
        if (isBidirectional) {
          const isSource = filterOutgoingConnections(targets);
          postFilter = (c) => isSource(c) !== isTarget(c);
        }
        connections = t$e(
          targets,
          t$m((target2) => {
            const sources = resolveAscendingSiblings(target2);
            return [...sources].flatMap((source2) => findConnection$2(source2, target2, dir));
          }),
          n$e(postFilter),
          applyPredicate(where)
        );
        break;
      }
      default: {
        invariant(!sourceIsWildcard, "Inferrence failed - source should be a deployment ref");
        invariant(!targetIsWildcard, "Inferrence failed - target should be a deployment ref");
        const sources = resolveElements$1(model, source);
        const targets = resolveElements$1(model, target);
        const isSource = filterOutgoingConnections(sources);
        const isTarget = filterIncomingConnections(targets);
        connections = t$e(
          sources,
          t$m((s) => findConnectionsBetween$2(s, targets, dir)),
          n$e((c) => isSource(c) && isTarget(c)),
          applyPredicate(where)
        );
      }
    }
    stage.addConnections(connections);
    if (FqnExpr.isDeploymentRef(source) && e$9(source.selector)) {
      stage.addImplicit(model.element(source.ref.deployment));
    }
    if (FqnExpr.isDeploymentRef(target) && e$9(target.selector)) {
      stage.addImplicit(model.element(target.ref.deployment));
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    const isTarget = deploymentExpressionToPredicate(expr.target);
    const isSource = deploymentExpressionToPredicate(expr.source);
    let modelRelationsToExclude;
    switch (true) {
      // * -> *
      case (FqnExpr.isWildcard(expr.source) && FqnExpr.isWildcard(expr.target)):
        stage.excludeConnections(applyPredicate(memory.connections, where));
        return stage;
      // model -> model
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isModelRef(expr.target)):
        modelRelationsToExclude = resolveRelationsBetweenModelElements({
          source: expr.source,
          target: expr.target,
          expr,
          model
        });
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> *
      case (FqnExpr.isModelRef(expr.source) && FqnExpr.isWildcard(expr.target)):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(modelRelationsToExclude, { stage, memory }, where);
      // model -> deployment
      case FqnExpr.isModelRef(expr.source):
        modelRelationsToExclude = resolveAllOutgoingRelations(model, expr.source);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c) => isTarget(c.target)
        );
      // deployment -> model
      case FqnExpr.isModelRef(expr.target):
        modelRelationsToExclude = resolveAllImcomingRelations(model, expr.target);
        return excludeModelRelations(
          modelRelationsToExclude,
          { stage, memory },
          where,
          (c) => isSource(c.source)
        );
      // deployment -> deployment
      default:
        const satisfies = (connection) => {
          return isSource(connection.source) && isTarget(connection.target) || expr.isBidirectional === true && isSource(connection.target) && isTarget(connection.source);
        };
        const deploymentRelationsToExclude = t$e(
          memory.connections,
          n$e(satisfies),
          applyPredicate(where)
        );
        if (deploymentRelationsToExclude.length === 0) {
          return stage;
        }
        stage.excludeConnections(deploymentRelationsToExclude);
        return stage;
    }
  }
};
function resolveRelationsBetweenModelElements({
  source,
  target,
  expr,
  model
}) {
  const sources = resolveModelElements(model, source);
  const targets = resolveModelElements(model, target);
  const dir = expr.isBidirectional ? "both" : "directed";
  const modelConnections = [];
  for (const source2 of sources) {
    modelConnections.push(...findConnectionsBetween$3(source2, targets, dir));
  }
  return new Set(modelConnections.flatMap((c) => [...c.relations]));
}

const InOutRelationPredicate$1 = {
  include: ({ expr, model, memory, stage, where }) => {
    const sources = [...memory.elements];
    if (FqnExpr.isWildcard(expr.inout)) {
      for (const source of sources) {
        const targets2 = [...resolveAscendingSiblings(source)];
        const toInclude = matchConnections(findConnectionsBetween$2(source, targets2, "both"), where);
        stage.addConnections(toInclude);
      }
      return stage;
    }
    invariant(FqnExpr.isDeploymentRef(expr.inout), "Only deployment refs are supported in include");
    const targets = resolveElements$1(model, expr.inout);
    for (const source of sources) {
      const toInclude = matchConnections(findConnectionsBetween$2(source, targets, "both"), where);
      stage.addConnections(toInclude);
    }
    return stage;
  },
  exclude: ({ expr, model, memory, stage, where }) => {
    if (FqnExpr.isElementTagExpr(expr.inout) || FqnExpr.isElementKindExpr(expr.inout)) {
      throw new Error("element kind and tag expressions are not supported in exclude");
    }
    if (FqnExpr.isModelRef(expr.inout)) {
      const elements2 = resolveModelElements(model, expr.inout);
      if (elements2.length === 0) {
        return stage;
      }
      const excludedRelations = union(
        /* @__PURE__ */ new Set(),
        ...elements2.flatMap((e) => [e.allIncoming, e.allOutgoing])
      );
      return excludeModelRelations(excludedRelations, { stage, memory }, where);
    }
    if (FqnExpr.isWildcard(expr.inout)) {
      return stage;
    }
    const elements = resolveElements$1(model, expr.inout);
    const isIncoming = filterIncomingConnections(elements);
    const isOutgoing = filterOutgoingConnections(elements);
    const toExclude = t$e(
      memory.connections,
      n$e((c) => isIncoming(c) !== isOutgoing(c)),
      applyPredicate(where)
    );
    stage.excludeConnections(toExclude);
    return stage;
  }
};

const WhereRelationPredicate = {
  include: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("include", { expr: expr.where.expr, model, stage, memory, where });
  },
  exclude: ({ expr, model, memory, stage }) => {
    const where = whereOperatorAsPredicate(expr.where.condition);
    return predicateToPatch("exclude", { expr: expr.where.expr, model, stage, memory, where });
  }
};

const WildcardPredicate$1 = {
  include: ({ model, stage, where }) => {
    const children = [];
    const rootElements = t$e(
      [...model.roots()],
      applyElementPredicate(where),
      t$f((root) => {
        if (!root.onlyOneInstance()) {
          children.push(...root.children());
        }
        return root;
      })
    );
    stage.addExplicit(rootElements);
    if (children.length > 1) {
      stage.addConnections(findConnectionsWithin$1([
        ...rootElements,
        ...children
      ]));
    }
    return stage;
  },
  exclude: ({ stage, memory, where }) => {
    const elementsToExclude = t$e(
      [...memory.elements],
      applyElementPredicate(where)
    );
    stage.exclude(elementsToExclude);
    return stage;
  }
};

function predicateToPatch(op, { expr, where, ...ctx }) {
  switch (true) {
    case FqnExpr.isElementTagExpr(expr):
    case FqnExpr.isElementKindExpr(expr):
      throw new Error("element kind and tag expressions are not supported in deployment view rules");
    case RelationExpr.isCustom(expr):
    case FqnExpr.isCustom(expr):
    case FqnExpr.isModelRef(expr):
      return void 0;
    case FqnExpr.isWhere(expr):
      return WhereDeploymentRefPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isWhere(expr):
      return WhereRelationPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isDeploymentRef(expr):
      return DeploymentRefPredicate[op]({ ...ctx, expr, where });
    case FqnExpr.isWildcard(expr):
      return WildcardPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isDirect(expr):
      return DirectRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isInOut(expr):
      return InOutRelationPredicate$1[op]({ ...ctx, expr, where });
    case RelationExpr.isOutgoing(expr):
      return OutgoingRelationPredicate[op]({ ...ctx, expr, where });
    case RelationExpr.isIncoming(expr):
      return IncomingRelationPredicate[op]({ ...ctx, expr, where });
    default:
      nonexhaustive(expr);
  }
}
function excludeModelRelations(relationsToExclude, { stage, memory }, where, filterConnections = () => true) {
  if (relationsToExclude.size === 0) {
    return stage;
  }
  const toExclude = t$e(
    memory.connections,
    n$e((c) => filterConnections(c)),
    // Find connections that have at least one relation in common with the excluded relations
    n$e((c) => hasIntersection(c.relations.model, relationsToExclude)),
    t$f(
      (c) => c.update({
        deployment: null,
        model: intersection(c.relations.model, relationsToExclude)
      })
    ),
    applyPredicate(where),
    n$e((c) => c.nonEmpty())
  );
  if (toExclude.length === 0) {
    return stage;
  }
  return stage.excludeConnections(toExclude);
}
function matchConnection(c, where) {
  return applyPredicate(c, where).nonEmpty();
}
function applyPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyPredicate(x, args[0]);
  }
  const [c, where] = args;
  if (where === null) {
    return c;
  }
  if (e$a(c)) {
    return c.map((x) => applyPredicate(x, where)).filter((x) => x.nonEmpty());
  }
  return c.update({
    model: new Set([...c.relations.model.values()].filter((r) => where(toFilterableRelation(c)(r)))),
    deployment: new Set([...c.relations.deployment.values()].filter((r) => where(toFilterableRelation(c)(r))))
  });
}
function applyElementPredicate(...args) {
  if (args.length === 1) {
    return (x) => applyElementPredicate(x, args[0]);
  }
  const [c, where] = args;
  if (e$a(c)) {
    return c.filter((x) => applyElementPredicate(x, where));
  }
  return where?.(toFilterable(c, c)) ?? true;
}
function matchConnections(connections, where) {
  if (!where) {
    return connections;
  }
  return t$e(
    connections,
    n$e((c) => matchConnection(c, where))
  );
}
function toFilterable(relationEndpoint, connectionEndpoint) {
  if (isElementModel(relationEndpoint)) {
    const deployedInstance = isDeploymentElementModel(connectionEndpoint) && isDeployedInstanceModel(connectionEndpoint) ? connectionEndpoint : null;
    return {
      kind: relationEndpoint.kind,
      tags: [...relationEndpoint.tags, ...deployedInstance?.tags ?? []]
    };
  }
  if (isNestedElementOfDeployedInstanceModel(relationEndpoint)) {
    return t$4(relationEndpoint.element, ["tags", "kind"]);
  }
  if (isDeployedInstanceModel(relationEndpoint)) {
    return {
      kind: relationEndpoint.element.kind,
      tags: [...relationEndpoint.tags, ...relationEndpoint.element.tags]
    };
  }
  if (isDeploymentNodeModel(relationEndpoint)) {
    return t$4(relationEndpoint, ["tags", "kind"]);
  }
  nonexhaustive(relationEndpoint);
}
function toFilterableRelation(c) {
  return (relation) => ({
    tags: relation.tags,
    kind: relation.kind,
    source: toFilterable(relation.source, c.source),
    target: toFilterable(relation.target, c.target)
  });
}

const DeploymentRefPredicate = {
  include: (ctx) => {
    const { expr, where } = ctx;
    const el = ctx.model.element(expr.ref.deployment);
    if (isDeployedInstanceModel(el)) {
      if (applyElementPredicate(el, where)) {
        ctx.stage.addExplicit(el);
        ctx.stage.connectWithExisting(el);
      }
      return ctx.stage;
    }
    switch (true) {
      case expr.selector === "expanded":
        includeDeployedNodeWithExpanded(el, ctx);
        break;
      case expr.selector === "children":
        includeDeployedNodeChildren(el, ctx);
        break;
      case expr.selector === "descendants":
        includeDeployedNodeDescendants(el, ctx);
        break;
      default: {
        if (applyElementPredicate(el, where)) {
          ctx.stage.addExplicit(el);
          ctx.stage.connectWithExisting(el);
        }
      }
    }
    return ctx.stage;
  },
  exclude: ({ expr, stage, memory, where }) => {
    const exprPredicate = deploymentExpressionToPredicate(expr);
    const toExclude = t$e(
      [...memory.elements],
      n$e(exprPredicate),
      applyElementPredicate(where)
    );
    stage.exclude(toExclude);
    return stage;
  }
};
function includeDeployedNodeChildren(node, { stage, where }) {
  const children = applyElementPredicate([...node.children()], where);
  if (children.length === 0) {
    return;
  }
  stage.addImplicit(node);
  stage.addConnections(findConnectionsWithin$1(children));
  stage.connectWithExisting(children);
  stage.addExplicit(children);
}
function includeDeployedNodeWithExpanded(node, { memory, stage, where }) {
  stage.addImplicit(node);
  stage.connectWithExisting(node);
  const children = applyElementPredicate([...node.children()], where);
  let hasConnectionsWithVisible = false;
  for (const child of children) {
    if (findConnectionsBetween$2(child, memory.elements).length > 0) {
      hasConnectionsWithVisible = true;
      break;
    }
  }
  if (hasConnectionsWithVisible) {
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin$1(children));
    stage.connectWithExisting(children, "out");
  }
  stage.addImplicit(children);
  if (stage.connections.length > 0) {
    stage.addExplicit(node);
  }
}
function includeDeployedNodeDescendants(node, { stage, where }) {
  const dfs = (node2) => {
    const children = [];
    for (const child of node2.children()) {
      if (child.isDeploymentNode()) {
        children.push(...dfs(child));
      }
      if (applyElementPredicate(child, where)) {
        children.push(child);
      }
    }
    stage.connectWithExisting(children, "in");
    stage.addConnections(findConnectionsWithin$1(children));
    stage.addImplicit(children);
    return children;
  };
  const descendants = dfs(node);
  if (descendants.length === 0) {
    return;
  }
  stage.connectWithExisting(descendants, "out");
  const allConnected = findConnectedElements(stage);
  t$e(
    descendants,
    n$e((desc) => allConnected.has(desc)),
    t$8((desc) => stage.addExplicit(desc))
  );
}
function findConnectedElements(stage) {
  return t$e(
    stage.mergedConnections(),
    cleanCrossBoundary,
    cleanRedundantRelationships,
    t$2((acc, c) => {
      acc.add(c.source);
      acc.add(c.target);
      return acc;
    }, /* @__PURE__ */ new Set())
  );
}

let StageFinal$1 = class StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connections = t$e(
      memory.connections,
      // Keep connections
      // - between leafs
      // - has direct deployment relation
      // filter(c => {
      //   return (leafs.has(c.source) && leafs.has(c.target)) || c.hasDirectDeploymentRelation()
      // }),
      cleanCrossBoundary,
      cleanRedundantRelationships
    );
    const connectionsToExclude = differenceConnections(
      memory.connections,
      connections
    );
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const groupedByRelation = new DefaultMap(() => /* @__PURE__ */ new Set());
    for (const conn of memory.connections) {
      if (conn.boundary) {
        for (const relation of conn.relations.model) {
          groupedByRelation.get(relation).add(conn.boundary);
        }
      }
    }
    for (const [_, boundaries] of groupedByRelation) {
      if (boundaries.size < 2) {
        continue;
      }
      for (const boundary of boundaries) {
        if (implicits.delete(boundary)) {
          final.add(boundary);
        }
      }
    }
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    t$e(
      difference(implicits, snapshot),
      ifilter((e) => e.isDeploymentNode()),
      toArray(),
      sortByFqnHierarchically,
      t$8((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$6([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$6(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  // TODO: Lot of corner cases to cover, skip for now
  // public step3FlatNodes(memory: Memory): Memory {
  //   // final implicits
  //   const explicits = new Set<Elem>([
  //     ...memory.explicits,
  //     ...memory.connections.flatMap(c => [c.source, c.target]),
  //   ])
  //   const sorted = sortParentsFirst(toArray(memory.final))
  //   const toplevel = new Set<Elem>(sorted)
  //   const children = sorted.reduce((acc, el, index, all) => {
  //     acc.set(
  //       el,
  //       new Set(
  //         all
  //           .slice(index + 1)
  //           .filter(e => isAncestor(el, e))
  //           .reduce((acc, el) => {
  //             if (!acc.some(e => isAncestor(e, el))) {
  //               toplevel.delete(el)
  //               acc.push(el)
  //             }
  //             return acc
  //           }, [] as Elem[]),
  //       ),
  //     )
  //     return acc
  //   }, new DefaultMap<Elem, Set<Elem>>(() => new Set()))
  //   const state = memory.mutableState()
  //   function flattenNode(node: Elem) {
  //     const _children = [...children.get(node)]
  //     if (_children.length > 1) {
  //       for (const child of _children) {
  //         flattenNode(child)
  //       }
  //       return !explicits.has(node)
  //     }
  //     if (hasAtLeast(_children, 1)) {
  //       if (flattenNode(_children[0])) {
  //         state.final.delete(_children[0])
  //       }
  //     }
  //     return !explicits.has(node)
  //   }
  //   const root = [...toplevel]
  //   for (const node of root) {
  //     flattenNode(node)
  //     if (!explicits.has(node) && children.get(node).size === 1) {
  //       state.final.delete(node)
  //     }
  //   }
  //   if (root.length === 1 && !explicits.has(root[0]!)) {
  //     state.final.delete(root[0]!)
  //   }
  //   return memory.update(state)
  // }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
};

function processPredicates$1(model, rules) {
  let memory = Memory$1.empty();
  for (const rule of rules) {
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        const ctx = { expr, model, stage, memory, where: null };
        stage = predicateToPatch(op, ctx) ?? stage;
        memory = stage.commit();
      }
    }
  }
  return StageFinal$1.for(memory).commit();
}
function computeDeploymentView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules,
  // exclude rules
  ...view
}) {
  const memory = processPredicates$1(likec4model.deployment, rules);
  const nodesMap = buildNodes$1(likec4model, memory);
  const computedEdges = toComputedEdges$1(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyDeploymentViewRuleStyles(
    rules,
    sorted.nodes
  );
  const autoLayoutRule = t$9(rules, isViewRuleAutoLayout);
  const elementNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    [_stage]: "computed",
    [_type]: "deployment",
    autoLayout: {
      direction: autoLayoutRule?.direction ?? "TB",
      ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
      ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
    },
    edges: sorted.edges,
    nodes: t$f(nodes, (n) => {
      if (n.icon === "none") {
        delete n.icon;
      }
      return n;
    }),
    ...elementNotations.length > 0 && {
      notation: {
        nodes: elementNotations
      }
    }
  });
}

function flattenGroupRules(guard) {
  return (rule) => {
    if (isViewRuleGroup(rule)) {
      return rule.groupRules.flatMap(flattenGroupRules(guard));
    }
    if (isViewRulePredicate(rule)) {
      return "include" in rule ? rule.include.filter(guard) : [];
    }
    return [];
  };
}
function applyCustomElementProperties(_rules, _nodes) {
  const rules = _rules.flatMap(flattenGroupRules(ModelFqnExpr.isCustom));
  if (rules.length === 0) {
    return _nodes;
  }
  const nodes = [..._nodes];
  for (const {
    custom: { expr, ...props }
  } of rules) {
    const {
      border,
      opacity,
      multiple,
      padding,
      size,
      textSize,
      description,
      ...rest
    } = t$o(props, e$b);
    const style = exact({
      border,
      opacity,
      multiple,
      padding,
      size,
      textSize
    });
    const styleNotEmpty = !e$5(style);
    const propsNotEmpty = !e$5(rest);
    const satisfies = elementExprToPredicate(expr);
    nodes.forEach((node, i) => {
      if (isGroupElementKind(node) || !satisfies(node)) {
        return;
      }
      if (propsNotEmpty) {
        node = {
          ...node,
          isCustomized: true,
          ...rest
        };
      }
      if (description !== void 0) {
        node = {
          ...node,
          isCustomized: true,
          description
        };
      }
      if (styleNotEmpty) {
        node = {
          ...node,
          isCustomized: true,
          style: {
            ...node.style,
            ...style
          }
        };
      }
      nodes[i] = node;
    });
  }
  return nodes;
}

function resolveGlobalRulesInElementView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.predicates[rule.predicateId];
      if (e$b(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (e$b(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}
function resolveGlobalRulesInDynamicView(rules, globals) {
  return rules.reduce((acc, rule) => {
    if (isViewRuleGlobalPredicateRef(rule)) {
      const globalPredicates = globals.dynamicPredicates[rule.predicateId];
      if (e$b(globalPredicates)) {
        return acc;
      }
      return acc.concat(globalPredicates);
    }
    if (isViewRuleGlobalStyle(rule)) {
      const globalStyles = globals.styles[rule.styleId];
      if (e$b(globalStyles)) {
        return acc;
      }
      return acc.concat(globalStyles);
    }
    acc.push(rule);
    return acc;
  }, []);
}

function elementsFromIncludeProperties(model, resolvedRules) {
  const explicits = /* @__PURE__ */ new Set();
  for (const rule of resolvedRules) {
    if (isViewRulePredicate(rule)) {
      for (const expr of rule.include) {
        const satisfies = elementExprToPredicate(expr);
        for (const e of model.elements()) {
          if (satisfies(e)) {
            explicits.add(e);
          }
        }
      }
    }
  }
  return explicits;
}
const flattenSteps = (s) => {
  if (isDynamicStepsParallel(s)) {
    const heads = [];
    const tails = [];
    for (const step of s.__parallel) {
      if (isDynamicStepsSeries(step)) {
        const [head, ...tail] = step.__series;
        heads.push(head);
        tails.push(...tail);
      } else {
        heads.push(step);
      }
    }
    return [...heads, ...tails];
  }
  if (isDynamicStepsSeries(s)) {
    return [...s.__series];
  }
  return s;
};
function elementsFromSteps(model, steps) {
  const actors = [];
  const addActor = (...[source, target]) => {
    if (!actors.includes(source)) {
      const indexOfTarget = actors.indexOf(target);
      if (indexOfTarget > 0) {
        actors.splice(indexOfTarget, 0, source);
        return;
      } else {
        actors.push(source);
      }
    }
    if (!actors.includes(target)) {
      actors.push(target);
    }
  };
  for (const step of t$m(steps, flattenSteps)) {
    const source = model.element(step.source);
    const target = model.element(step.target);
    let sourceColumn = actors.indexOf(source);
    let targetColumn = actors.indexOf(target);
    const alreadyAdded = sourceColumn >= 0 && targetColumn >= 0;
    if (alreadyAdded) {
      continue;
    }
    if (step.isBackward) {
      addActor(target, source);
    } else {
      addActor(source, target);
    }
  }
  return new Set(actors);
}
function findRelations(source, target, currentViewId) {
  const relationships = findConnection$3(source, target, "directed").flatMap((r) => [...r.relations]).sort(compareRelations);
  if (!isNonEmptyArray(relationships)) {
    return {};
  }
  if (relationships.length === 1) {
    const relation2 = relationships[0];
    return exact({
      title: relation2.title ?? void 0,
      tags: relation2.tags,
      relations: [relation2.id],
      navigateTo: relation2.$relationship.navigateTo,
      color: relation2.$relationship.color,
      line: relation2.$relationship.line
    });
  }
  const alltags = t$e(
    relationships,
    t$m((r) => r.tags),
    n$f()
  );
  const tags = t$c(alltags, 1) ? alltags : void 0;
  const relations = t$f(relationships, (r) => r.id);
  const relation = n$a(relationships);
  let navigateTo = relation.$relationship.navigateTo;
  if (navigateTo === currentViewId) {
    navigateTo = void 0;
  }
  if (!navigateTo) {
    navigateTo = t$e(
      relationships,
      t$m(
        (r) => r.$relationship.navigateTo && r.$relationship.navigateTo !== currentViewId ? r.$relationship.navigateTo : []
      ),
      n$f(),
      t$6()
    );
  }
  const commonProperties = t$e(
    relationships,
    t$2((acc, { title, $relationship: r }) => {
      e$4(title) && acc.title.add(title);
      e$4(r.color) && acc.color.add(r.color);
      e$4(r.line) && acc.line.add(r.line);
      e$4(r.kind) && acc.kind.add(r.kind);
      return acc;
    }, {
      kind: /* @__PURE__ */ new Set(),
      color: /* @__PURE__ */ new Set(),
      line: /* @__PURE__ */ new Set(),
      title: /* @__PURE__ */ new Set()
    })
  );
  return exact({
    tags: tags ?? void 0,
    relations,
    navigateTo,
    kind: t$6([...commonProperties.kind]),
    title: t$6([...commonProperties.title]),
    color: t$6([...commonProperties.color]),
    line: t$6([...commonProperties.line])
  });
}

class DynamicViewCompute {
  constructor(model, view) {
    this.model = model;
    this.view = view;
  }
  // Intermediate state
  steps = [];
  compute() {
    const {
      docUri: _docUri,
      // exclude docUri
      rules: _rules,
      // exclude rules
      steps: viewSteps,
      ...view
    } = this.view;
    const rules = resolveGlobalRulesInDynamicView(_rules, this.model.globals);
    const explicits = elementsFromIncludeProperties(this.model, rules);
    const fromSteps = elementsFromSteps(this.model, viewSteps);
    const actors = t$e(
      union(
        // First all actors, that are explicitly included
        intersection(explicits, fromSteps),
        // Then all actors from steps
        fromSteps,
        // Then all explicits (not from steps)
        explicits
      ),
      toArray(),
      sortParentsFirst
    );
    const compounds = actors.reduce((acc, actor, index, all) => {
      for (let i = index + 1; i < all.length; i++) {
        const other = all[i];
        if (isAncestor(actor, other)) {
          acc.push(actor);
          break;
        }
      }
      return acc;
    }, []);
    const processStep = (step, stepNum2, prefix) => {
      if (isDynamicStepsSeries(step)) {
        for (const s of step.__series) {
          stepNum2 = processStep(s, stepNum2, prefix);
        }
        return stepNum2;
      }
      const id = prefix ? stepEdgeId(prefix, stepNum2) : stepEdgeId(stepNum2);
      const {
        source: stepSource,
        target: stepTarget,
        title: stepTitle,
        isBackward: _isBackward,
        // omit
        navigateTo: stepNavigateTo,
        notation: _notation,
        // omit
        ...rest
      } = step;
      const source = this.model.element(stepSource);
      const sourceColumn = actors.indexOf(source);
      invariant(sourceColumn >= 0, `Source ${stepSource} not found`);
      const target = this.model.element(stepTarget);
      const targetColumn = actors.indexOf(target);
      invariant(targetColumn >= 0, `Target ${stepTarget} not found`);
      if (compounds.includes(source) || compounds.includes(target)) {
        console.error(`Step ${source.id} -> ${target.id} because it involves a compound`);
      }
      const {
        title,
        relations,
        navigateTo: derivedNavigateTo,
        ...derived
      } = findRelations(source, target, this.view.id);
      const navigateTo = e$4(stepNavigateTo) && stepNavigateTo !== this.view.id ? stepNavigateTo : derivedNavigateTo;
      this.steps.push(exact({
        ...derived,
        ...rest,
        id,
        source,
        target,
        navigateTo,
        title: stepTitle ?? title,
        relations: relations ?? [],
        isBackward: sourceColumn > targetColumn
      }));
      return stepNum2 + 1;
    };
    let stepNum = 1;
    for (const step of viewSteps) {
      if (isDynamicStepsParallel(step)) {
        let nestedStepNum = 1;
        for (const s of step.__parallel) {
          nestedStepNum = processStep(s, nestedStepNum, stepNum);
        }
        stepNum++;
        continue;
      }
      stepNum = processStep(step, stepNum);
    }
    const nodesMap = buildComputedNodes(
      this.model.$styles,
      actors.map(elementModelToNodeSource)
    );
    const defaults = this.model.$styles.defaults.relationship;
    const edges = this.steps.map(({ id, source, target, relations, title, isBackward, tags, ...step }) => {
      const sourceNode = nonNullable(nodesMap.get(source.id), `Source node ${source.id} not found`);
      const targetNode = nonNullable(nodesMap.get(target.id), `Target node ${target.id} not found`);
      const edge = {
        id,
        parent: commonAncestor(source.id, target.id),
        source: sourceNode.id,
        target: targetNode.id,
        label: title ?? null,
        relations,
        color: defaults.color,
        line: defaults.line,
        head: defaults.arrow,
        tags: tags ?? [],
        ...step
      };
      if (isBackward) {
        edge.dir = "back";
      }
      while (edge.parent && !nodesMap.has(edge.parent)) {
        edge.parent = parentFqn(edge.parent);
      }
      sourceNode.outEdges.push(edge.id);
      targetNode.inEdges.push(edge.id);
      for (const sourceAncestor of ancestorsFqn(edge.source)) {
        if (sourceAncestor === edge.parent) {
          break;
        }
        nodesMap.get(sourceAncestor)?.outEdges.push(edge.id);
      }
      for (const targetAncestor of ancestorsFqn(edge.target)) {
        if (targetAncestor === edge.parent) {
          break;
        }
        nodesMap.get(targetAncestor)?.inEdges.push(edge.id);
      }
      return edge;
    });
    const nodes = applyCustomElementProperties(
      rules,
      applyViewRuleStyles(
        rules,
        // Keep order of elements
        actors.map((e) => nonNullable(nodesMap.get(e.id)))
      )
    );
    const autoLayoutRule = t$9(rules, isViewRuleAutoLayout);
    const nodeNotations = buildElementNotations(nodes);
    return calcViewLayoutHash({
      ...view,
      [_type]: "dynamic",
      [_stage]: "computed",
      variant: view.variant ?? "diagram",
      autoLayout: {
        direction: autoLayoutRule?.direction ?? "LR",
        ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
        ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
      },
      nodes: t$f(nodes, (n) => {
        if (n.icon === "none") {
          delete n.icon;
        }
        return n;
      }),
      edges,
      ...nodeNotations.length > 0 && {
        notation: {
          nodes: nodeNotations
        }
      }
    });
  }
}
function computeDynamicView(model, view) {
  return new DynamicViewCompute(model, view).compute();
}

function relationExpressionToPredicates(expr) {
  switch (true) {
    case ModelRelationExpr.isCustom(expr): {
      return relationExpressionToPredicates(expr.customRelation.expr);
    }
    case ModelRelationExpr.isWhere(expr): {
      const predicate = relationExpressionToPredicates(expr.where.expr);
      const where = whereOperatorAsPredicate(expr.where.condition);
      return (e) => predicate(e) && where({
        source: { tags: e.source.tags, kind: e.source.kind },
        target: { tags: e.target.tags, kind: e.target.kind },
        ...e.tags && { tags: e.tags },
        ...e.kind && { kind: e.kind }
      });
    }
    case ModelRelationExpr.isDirect(expr): {
      const isSource = elementExprToPredicate(expr.source);
      const isTarget = elementExprToPredicate(expr.target);
      return (edge) => {
        return isSource(edge.source) && isTarget(edge.target) || !!expr.isBidirectional && isSource(edge.target) && isTarget(edge.source);
      };
    }
    case ModelRelationExpr.isInOut(expr): {
      const isInOut = elementExprToPredicate(expr.inout);
      return (edge) => isInOut(edge.source) || isInOut(edge.target);
    }
    case ModelRelationExpr.isIncoming(expr): {
      const isTarget = elementExprToPredicate(expr.incoming);
      return (edge) => isTarget(edge.target);
    }
    case ModelRelationExpr.isOutgoing(expr): {
      const isSource = elementExprToPredicate(expr.outgoing);
      return (edge) => isSource(edge.source);
    }
    default:
      nonexhaustive(expr);
  }
}

function applyCustomRelationProperties(_rules, nodes, _edges) {
  const rules = _rules.flatMap(flattenGroupRules(ModelRelationExpr.isCustom));
  const edges = Array.from(_edges);
  if (rules.length === 0 || edges.length === 0) {
    return edges;
  }
  for (const {
    customRelation: {
      expr,
      title,
      description: _description,
      notes: _notes,
      ...customprops
    }
  } of rules) {
    const description = _description ? { description: { txt: _description } } : {};
    const notes = _notes ? { notes: { txt: _notes } } : {};
    const props = t$o(customprops, e$b);
    const satisfies = relationExpressionToPredicates(expr);
    edges.forEach((edge, i) => {
      let source, target;
      for (const node of nodes) {
        if (node.id === edge.source) {
          source = node;
        }
        if (node.id === edge.target) {
          target = node;
        }
        if (source && target) {
          break;
        }
      }
      if (!source || !target) {
        return;
      }
      if (satisfies({ source, target, ...t$4(edge, ["kind", "tags"]) })) {
        edges[i] = {
          ...edge,
          ...props,
          ...description,
          ...notes,
          label: title ?? edge.label,
          isCustomized: true
        };
      }
    });
  }
  return edges;
}

class NodesGroup {
  constructor(id, viewRule, parent = null, elements = /* @__PURE__ */ new Set()) {
    this.id = id;
    this.viewRule = viewRule;
    this.parent = parent;
    this.elements = elements;
  }
  static kind = GroupElementKind;
  isEmpty() {
    return this.elements.size === 0;
  }
  update(elements) {
    return new NodesGroup(
      this.id,
      this.viewRule,
      this.parent,
      elements
    );
  }
  clone() {
    return new NodesGroup(this.id, this.viewRule, this.parent, new Set(this.elements));
  }
}

class StageExclude extends AbstractStageExclude {
  excludeRelations(excluded) {
    t$e(
      this.memory.connections,
      n$e((c) => hasIntersection(c.relations, excluded)),
      t$8((c) => {
        this.excludeConnections(
          c.update(intersection(c.relations, excluded))
        );
      })
    );
    return this;
  }
  /**
   * Precommit hook
   */
  precommit(state) {
    if (this.excluded.elements.size > 0) {
      const excludeRelationships = new Set(
        [...this.excluded.elements].flatMap((el) => [
          ...el.incoming("direct"),
          ...el.outgoing("direct")
        ])
      );
      this.excludeRelations(excludeRelationships);
    }
    return state;
  }
  postcommit(state) {
    const leftExplicits = difference(this.memory.explicits, state.explicits);
    for (const explicit of leftExplicits) {
      state.explicitFirstSeenIn.delete(explicit);
    }
    const left = difference(this.memory.elements, state.elements);
    for (const el of left) {
      state.lastSeenIn.delete(el);
    }
    return state;
  }
}
class ActiveGroupStageExclude extends StageExclude {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
}

const { findConnection: findConnection$1, findConnectionsBetween: findConnectionsBetween$1 } = modelConnection;
class StageInclude extends AbstractStageInclude {
  /**
   * Connects elements with existing ones in the memory
   */
  connectWithExisting(elements, direction = "both") {
    const before = this._connections.length;
    const hasChanged = () => this._connections.length > before;
    if (!isIterable(elements)) {
      if (direction === "in" || direction === "both") {
        for (const el of this.memory.elements) {
          this.addConnections(
            findConnection$1(el, elements, "directed")
          );
        }
      }
      if (direction === "out" || direction === "both") {
        this.addConnections(
          findConnectionsBetween$1(elements, this.memory.elements, "directed")
        );
      }
      return hasChanged();
    }
    const targets = [...elements];
    if (direction === "in" || direction === "both") {
      for (const el of this.memory.elements) {
        this.addConnections(
          findConnectionsBetween$1(el, targets, "directed")
        );
      }
    }
    if (direction === "out" || direction === "both") {
      for (const el of targets) {
        this.addConnections(
          findConnectionsBetween$1(el, this.memory.elements, "directed")
        );
      }
    }
    return hasChanged();
  }
  addImplicitWithinScope(element) {
    if (!element) {
      return;
    }
    if (!this.memory.scope || isAncestor(this.memory.scope, element)) {
      this.addImplicit(element);
    }
  }
  processConnections(connections) {
    if (ModelExpression.isRelationExpr(this.expression)) {
      return connections;
    }
    t$e(
      connections,
      t$8(({ source, target, boundary }) => {
        t$e(
          t$n(
            [...toArray(source.ancestors()).reverse(), source],
            [...toArray(target.ancestors()).reverse(), target]
          ),
          // Filter out common ancestors
          t$a(([sourceAncestor, targetAncestor]) => sourceAncestor === targetAncestor),
          n(1),
          t$8(([sourceAncestor, targetAncestor]) => {
            if (sourceAncestor === source && targetAncestor === target) {
              this.addImplicitWithinScope(boundary);
              return;
            }
            if (sourceAncestor !== source) {
              this.addImplicitWithinScope(sourceAncestor);
            }
            if (targetAncestor !== target) {
              this.addImplicitWithinScope(targetAncestor);
            }
          })
        );
      })
    );
    return connections;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, "@root");
    }
    return state;
  }
}
class ActiveGroupStageInclude extends StageInclude {
  constructor(memory, expression) {
    super(memory, expression);
    this.memory = memory;
    this.expression = expression;
  }
  postcommit(state) {
    const newExplicits = difference(state.explicits, this.memory.explicits);
    for (const explicit of newExplicits) {
      state.explicitFirstSeenIn.set(explicit, this.memory.activeGroupId);
    }
    for (const implicit of [...this.explicits, ...this.implicits]) {
      state.lastSeenIn.set(implicit, this.memory.activeGroupId);
    }
    return state;
  }
}

class Memory extends AbstractMemory {
  constructor(state, scope) {
    super(state);
    this.state = state;
    this.scope = scope;
  }
  static empty(scope) {
    return new Memory({
      elements: /* @__PURE__ */ new Set(),
      explicits: /* @__PURE__ */ new Set(),
      final: /* @__PURE__ */ new Set(),
      connections: [],
      groups: [],
      explicitFirstSeenIn: /* @__PURE__ */ new Map(),
      lastSeenIn: /* @__PURE__ */ new Map()
    }, scope);
  }
  get groups() {
    return this.state.groups;
  }
  get explicitFirstSeenIn() {
    return this.state.explicitFirstSeenIn;
  }
  get lastSeenIn() {
    return this.state.lastSeenIn;
  }
  stageInclude(expr) {
    return new StageInclude(this, expr);
  }
  stageExclude(expr) {
    return new StageExclude(this, expr);
  }
  mutableState() {
    return {
      elements: new Set(this.state.elements),
      explicits: new Set(this.state.explicits),
      final: new Set(this.state.final),
      connections: [...this.state.connections],
      groups: this.state.groups.map((g) => g.clone()),
      explicitFirstSeenIn: new Map(this.state.explicitFirstSeenIn),
      lastSeenIn: new Map(this.state.lastSeenIn)
    };
  }
  update(newstate) {
    return new Memory({
      ...this.state,
      ...newstate
    }, this.scope);
  }
}
class ActiveGroupMemory extends Memory {
  constructor(state, scope, stack) {
    super(state, scope);
    this.state = state;
    this.scope = scope;
    this.stack = stack;
  }
  static enter(memory, rule) {
    const groupId = `@gr${memory.groups.length + 1}`;
    if (memory instanceof ActiveGroupMemory) {
      const stack2 = Stack.from([...memory.stack].reverse());
      const state2 = memory.mutableState();
      state2.groups.push(new NodesGroup(groupId, rule, memory.activeGroupId));
      stack2.push(groupId);
      return new ActiveGroupMemory(state2, memory.scope, stack2);
    }
    const state = memory.mutableState();
    state.groups.push(new NodesGroup(groupId, rule, null));
    const stack = Stack.of(groupId);
    return new ActiveGroupMemory(state, memory.scope, stack);
  }
  get activeGroupId() {
    return nonNullable(this.stack.peek(), "Stack must not be empty");
  }
  mutableState() {
    const state = super.mutableState();
    return {
      ...state
      // activeGroup: this.findActiveGroup(state.groups)
    };
  }
  // private findActiveGroup(groups: NodesGroup[]): NodesGroup {
  //   return nonNullable(groups.find(g => g.id === this.activeGroup.id), 'Active group not found in groups')
  // }
  update(newstate) {
    const nextstate = {
      ...this.state,
      ...newstate
    };
    return new ActiveGroupMemory(nextstate, this.scope, this.stack);
  }
  stageInclude(expr) {
    return new ActiveGroupStageInclude(this, expr);
  }
  stageExclude(expr) {
    return new ActiveGroupStageExclude(this, expr);
  }
  leave() {
    const state = this.mutableState();
    this.stack.pop();
    const prevgroup = this.stack.peek();
    if (prevgroup) {
      return new ActiveGroupMemory(state, this.scope, this.stack);
    }
    return new Memory(state, this.scope);
  }
}

function findRedundantConnections(connections) {
  return t$e(
    [...connections],
    mergeConnections,
    t$2((reducedConnections, connection, _, all) => {
      const descendants = findDescendantConnections(all, connection);
      const nestedRelations = union(
        ...descendants.map(e$8("relations"))
      );
      let accum = intersection(connection.relations, nestedRelations);
      if (descendants.length > 0) {
        accum = union(accum, connection.directRelations);
      }
      if (findDeepestNestedConnection(all, connection.reversed(false))) {
        accum = union(accum, connection.directRelations);
      }
      if (accum.size < connection.relations.size) {
        const isSourceExpanded = all.some(isAnyInOut(connection.source));
        const isTargetExpanded = all.some(isAnyInOut(connection.target));
        if (isSourceExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isOutgoing(connection.source)
              )
            )
          );
        }
        if (isTargetExpanded) {
          accum = union(
            accum,
            toSet(
              ifilter(
                connection.relations,
                isIncoming(connection.target)
              )
            )
          );
        }
      }
      if (accum.size > 0) {
        reducedConnections.push(connection.update(accum));
      }
      return reducedConnections;
    }, [])
  );
}

class StageFinal {
  constructor(memory) {
    this.memory = memory;
  }
  static for(memory) {
    return new StageFinal(memory);
  }
  step1CleanConnections(memory) {
    if (memory.connections.length < 2) {
      return memory;
    }
    const connectionsToExclude = findRedundantConnections(memory.connections);
    if (connectionsToExclude.length === 0) {
      return memory;
    }
    const stage = memory.stageExclude({});
    stage.excludeConnections(connectionsToExclude, true);
    return stage.commit();
  }
  step2ProcessImplicits(memory) {
    const implicits = union(this.memory.elements, memory.elements);
    const final = union(memory.final, this.memory.explicits);
    const snapshot = new Set(final);
    const isFinalOrHasIncludedDescendant = (el) => {
      for (const final2 of snapshot) {
        if (el === final2 || isAncestor(el, final2)) {
          return true;
        }
      }
      return false;
    };
    t$e(
      difference(implicits, snapshot),
      toArray(),
      sortByFqnHierarchically,
      t$8((el) => {
        const childrensToWrap = [...el.children()].filter(isFinalOrHasIncludedDescendant).length;
        if (childrensToWrap >= 2) {
          final.add(el);
          return;
        }
        if (childrensToWrap === 1 && isome(el.siblings(), isFinalOrHasIncludedDescendant)) {
          final.add(el);
        }
      })
    );
    return memory.update({ final });
  }
  step3ProcessBoundaries(memory) {
    const boundaries = /* @__PURE__ */ new Set();
    for (const conn of memory.connections) {
      if (conn.boundary && conn.boundary !== conn.source && conn.boundary !== conn.target) {
        boundaries.add(conn.boundary);
      }
    }
    const tree = treeFromMemoryState(memory, "final");
    const stage = memory.stageExclude({});
    const isRemovable = (el) => !(boundaries.has(el) || memory.explicits.has(el) || tree.hasInOut(el) || tree.root.has(el));
    const singleRoot = t$6([...tree.root]);
    if (singleRoot && !memory.explicits.has(singleRoot)) {
      stage.exclude(singleRoot);
    }
    for (const el of memory.final) {
      const singleChild = t$6(tree.children(el));
      if (singleChild && !tree.hasInOut(singleChild) && isRemovable(el)) {
        stage.exclude(el);
      }
    }
    if (stage.isDirty()) {
      return stage.commit();
    }
    return memory;
  }
  commit() {
    const step1 = this.step1CleanConnections(this.memory);
    const step2 = this.step2ProcessImplicits(step1);
    return this.step3ProcessBoundaries(step2);
  }
}

const { findConnection, findConnectionsBetween, findConnectionsWithin } = modelConnection;
function resolveElements(model, expr) {
  switch (true) {
    case ModelFqnExpr.isElementKindExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === (el.kind === expr.elementKind);
      })];
    }
    case ModelFqnExpr.isElementTagExpr(expr): {
      return [...ifilter(model.elements(), (el) => {
        return expr.isEqual === el.tags.includes(expr.elementTag);
      })];
    }
    case expr.selector === "expanded": {
      const element = model.element(FqnRef.flatten(expr.ref));
      return [
        element,
        ...element.children()
      ];
    }
    case expr.selector === "children":
    case expr.selector === "descendants": {
      const element = model.element(FqnRef.flatten(expr.ref));
      let children = expr.selector === "children" ? toArray(element.children()) : toArray(element.descendants());
      return children && children.length > 0 ? children : [element];
    }
    case ModelFqnExpr.isModelRef(expr): {
      return [model.element(FqnRef.flatten(expr.ref))];
    }
    default:
      nonexhaustive(expr);
  }
}
function includeDescendantsFromMemory(elements, memory) {
  if (memory.isEmpty() || elements.length === 0) {
    return elements;
  }
  const descedantsOf = t$h(elements.map((e) => isDescendantOf(e)));
  const fromMemory = toArray(
    ifilter(
      memory.elements,
      (el) => !elements.includes(el) && descedantsOf(el)
    )
  );
  return [
    ...elements,
    ...fromMemory
  ];
}
function resolveAndIncludeFromMemory(nonWildcard, { memory, model }) {
  const resolved = resolveElements(model, nonWildcard);
  if (ModelFqnExpr.isModelRef(nonWildcard)) {
    if (nonWildcard.selector === "descendants") {
      return resolved;
    }
    return includeDescendantsFromMemory(resolved, memory);
  }
  return resolved;
}

const ExpandedElementPredicate = {
  include: ({ expr, model, stage, where }) => {
    const parent = model.element(FqnRef.flatten(expr.ref));
    if (where(parent)) {
      stage.addExplicit(parent);
      stage.connectWithExisting(parent);
    }
    const children = [...parent.children()].filter(where);
    const expanded = [];
    for (const child of children) {
      stage.addImplicit(child);
      if (stage.connectWithExisting(child)) {
        expanded.push(child);
      }
    }
    stage.addConnections(findConnectionsWithin(expanded));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const ElementKindOrTagPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const ElementRefPredicate = {
  include: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    if (elements.length === 0) {
      return;
    }
    stage.addExplicit(elements);
    stage.connectWithExisting(elements);
    stage.addConnections(findConnectionsWithin(elements));
    return stage;
  },
  exclude: ({ expr, model, stage, filterWhere }) => {
    const elements = filterWhere(resolveElements(model, expr));
    stage.exclude(elements);
    return stage;
  }
};

const NoWhere = () => true;
const NoFilter = (x) => x;
function toComputedEdges(connections) {
  return connections.reduce((acc, e) => {
    const relations = [
      ...e.relations
    ];
    invariant(t$c(relations, 1), "Edge must have at least one relation");
    const $defaults = e.source.$model.$styles.defaults;
    const source = e.source.id;
    const target = e.target.id;
    const {
      title,
      color = $defaults.relationship.color,
      line = $defaults.relationship.line,
      head = $defaults.relationship.arrow,
      ...props
    } = mergePropsFromRelationships(
      relations.map((r) => r.$relationship),
      // Prefer only single relationship
      // https://github.com/likec4/likec4/issues/1423
      t$6(
        n$e(relations, (r) => r.source.id === source && r.target.id === target)
      )?.$relationship
    );
    const edge = exact({
      id: e.id,
      parent: e.boundary?.id ?? null,
      source,
      target,
      label: title ?? null,
      relations: relations.map((r) => r.id),
      color,
      line,
      head,
      ...props
    });
    acc.push(edge);
    return acc;
  }, []);
}
function buildNodes(model, memory) {
  return buildComputedNodes(
    model.$styles,
    [...memory.final].map(elementModelToNodeSource),
    memory.groups
  );
}

const isWildcard = ModelFqnExpr.isWildcard;
const isAncestorOrDescendantOf = (a, b) => a.isAncestorOf(b) || a.isDescendantOf(b);
const DirectRelationExprPredicate = {
  include: ({ expr: { source, target, isBidirectional = false }, memory, model, stage, where, filterWhere }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    const connections = [];
    switch (true) {
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> * ; Empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && memory.isEmpty() && where !== NoWhere): {
        const connections2 = t$e(
          model.relationships(),
          ifilter(where),
          toArray(),
          t$f((r) => new ConnectionModel(r.source, r.target, /* @__PURE__ */ new Set([r])))
        );
        stage.addConnections(connections2);
        return stage;
      }
      // This is a special case, we look for all relationships between elements that satisfy the where clause
      // * -> *; Not empty memory; Where clause
      case (sourceIsWildcard && targetIsWildcard && !memory.isEmpty() && where !== NoWhere): {
        connections.push(
          ...findConnectionsWithin(memory.elements)
        );
        break;
      }
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        connections.push(
          ...findConnectionsWithin(model.roots())
        );
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // element -> *; Where clause
      case (!sourceIsWildcard && targetIsWildcard && where !== NoWhere): {
        const sources = resolveElements(model, source);
        const connections2 = t$e(
          sources,
          t$m(
            (source2) => t$e(
              source2,
              e(e$3(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allOutgoing
              }),
              ifilter(where),
              iunique(),
              toArray(),
              t$5((r) => r.source === source2),
              ([outgoing, incoming]) => t$p(
                t$e(
                  outgoing,
                  n$e((r) => !isAncestorOrDescendantOf(source2, r.target)),
                  t$f(
                    (outgoing2) => new ConnectionModel(
                      source2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                t$e(
                  incoming,
                  n$e((r) => !isAncestorOrDescendantOf(source2, r.source)),
                  t$f(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      source2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const [sources, targets] = resolveWildcard(source, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween(source2, targets, dir)
          );
        }
        break;
      }
      // This is a special case, we look for all relationships that satisfy the where clause
      // * -> element; Where clause
      case (sourceIsWildcard && !targetIsWildcard && where !== NoWhere): {
        const targets = resolveElements(model, target);
        const connections2 = t$e(
          targets,
          t$m(
            (target2) => t$e(
              target2,
              e(e$3(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allIncoming
              }),
              ifilter(where),
              toArray(),
              t$5((r) => r.target === target2),
              ([incoming, outgoing]) => t$p(
                t$e(
                  outgoing,
                  n$e((r) => !isAncestorOrDescendantOf(target2, r.target)),
                  t$f(
                    (outgoing2) => new ConnectionModel(
                      target2,
                      outgoing2.target,
                      /* @__PURE__ */ new Set([outgoing2])
                    )
                  )
                ),
                t$e(
                  incoming,
                  n$e((r) => !isAncestorOrDescendantOf(target2, r.source)),
                  t$f(
                    (incoming2) => new ConnectionModel(
                      incoming2.source,
                      target2,
                      /* @__PURE__ */ new Set([incoming2])
                    )
                  )
                )
              )
            )
          )
        );
        stage.addConnections(connections2);
        return stage;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const [targets, sources] = resolveWildcard(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween(source2, targets, dir)
          );
        }
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inference failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inference failed - target must be not a wildcard");
        const sources = resolveAndIncludeFromMemory(source, { memory, model });
        const targets = resolveAndIncludeFromMemory(target, { memory, model });
        const dir = isBidirectional ? "both" : "directed";
        for (const source2 of sources) {
          connections.push(
            ...findConnectionsBetween(source2, targets, dir)
          );
        }
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { source, target, isBidirectional }, model, memory, stage, where }) => {
    const sourceIsWildcard = isWildcard(source);
    const targetIsWildcard = isWildcard(target);
    let relations;
    switch (true) {
      // * -> *
      case (sourceIsWildcard && targetIsWildcard): {
        relations = t$e(
          memory.connections,
          t$m(t$j(
            e$8("relations"),
            ifilter(where),
            toArray()
          )),
          toSet()
        );
        break;
      }
      // element -> *
      case (!sourceIsWildcard && targetIsWildcard): {
        const sources = resolveElements(model, source);
        relations = t$e(
          sources,
          t$m(
            (source2) => t$e(
              source2,
              e(e$3(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allOutgoing
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      // * -> element
      case (sourceIsWildcard && !targetIsWildcard): {
        const targets = resolveElements(model, target);
        relations = t$e(
          targets,
          t$m(
            (target2) => t$e(
              target2,
              e(e$3(isBidirectional === true), {
                onTrue: (s) => union(s.allIncoming, s.allOutgoing),
                onFalse: (s) => s.allIncoming
              }),
              ifilter(where),
              toArray()
            )
          ),
          toSet()
        );
        break;
      }
      default: {
        invariant(!isWildcard(source), "Inferrence failed - source must be not a wildcard");
        invariant(!isWildcard(target), "Inferrence failed - target must be not a wildcard");
        const sources = resolveElements(model, source);
        const targets = resolveElements(model, target);
        let accum = /* @__PURE__ */ new Set();
        for (const source2 of sources) {
          for (const target2 of targets) {
            if (isSameHierarchy(source2, target2)) {
              continue;
            }
            accum = union(
              accum,
              intersection(source2.allOutgoing, target2.allIncoming),
              isBidirectional ? intersection(target2.allOutgoing, source2.allIncoming) : /* @__PURE__ */ new Set()
            );
          }
        }
        relations = toSet(ifilter(accum, where));
      }
    }
    stage.excludeRelations(relations);
    return stage;
  }
};
function resolveWildcard(nonWildcard, { memory, model }) {
  let sources = resolveElements(model, nonWildcard);
  if (!t$c(sources, 1)) {
    return [[], []];
  }
  if (ModelFqnExpr.isModelRef(nonWildcard)) {
    const parent = model.element(FqnRef.flatten(nonWildcard.ref));
    const targets2 = toArray(parent.ascendingSiblings());
    return [
      includeDescendantsFromMemory(sources, memory),
      includeDescendantsFromMemory(targets2, memory)
    ];
  }
  const targets = t$e(
    sources,
    t$f((el) => el.ascendingSiblings()),
    iflat(),
    iunique(),
    toArray(),
    (all) => includeDescendantsFromMemory(all, memory)
  );
  return [sources, targets];
}

const IncomingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.incoming;
    const connections = [];
    if (ModelFqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      for (const sibling of scope.ascendingSiblings()) {
        connections.push(
          ...findConnection(
            sibling,
            scope,
            "directed"
          )
        );
      }
    } else {
      const targets = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...n$f(
            targets.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureIncoming = incomingConnectionPredicate(model, target);
      for (const visible of visibleElements) {
        connections.push(
          ...findConnectionsBetween(
            visible,
            targets,
            "directed"
          ).filter(ensureIncoming)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { incoming }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelFqnExpr.isWildcard(incoming)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, incoming);
      excluded.push(
        ...elements.flatMap((e) => [...e.allIncoming])
      );
    }
    stage.excludeRelations(new Set(excluded.filter(where)));
    return stage;
  }
};
function incomingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelFqnExpr.isElementKindExpr(expr):
    case ModelFqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.target);
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h(
        [...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      );
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isIncoming(el.id)
        )
      ]);
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h([
        Connection.isIncoming(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelFqnExpr.isModelRef(expr): {
      const fqn = FqnRef.flatten(expr.ref);
      return Connection.isIncoming(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}

const InOutRelationPredicate = {
  include: ({ expr: { inout }, scope, model, memory, stage, filterWhere }) => {
    const connections = [];
    if (ModelFqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween(
          scope,
          scope.ascendingSiblings()
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(inout, { memory, model });
      let visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements = n$f(
          elements.flatMap((el) => toArray(el.ascendingSiblings()))
        );
      }
      for (const el of elements) {
        connections.push(
          ...findConnectionsBetween(
            el,
            visibleElements
          )
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { inout }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelFqnExpr.isWildcard(inout)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
      excluded.push(...scope.allIncoming);
    } else {
      const elements = resolveElements(model, inout);
      excluded.push(
        ...elements.flatMap((e) => [...e.allOutgoing, ...e.allIncoming])
      );
    }
    stage.excludeRelations(toSet(excluded.filter(where)));
    return stage;
  }
};

const OutgoingExprPredicate = {
  include: ({ expr, scope, model, memory, stage, filterWhere }) => {
    const target = expr.outgoing;
    const connections = [];
    if (ModelFqnExpr.isWildcard(target)) {
      if (!scope) {
        return;
      }
      connections.push(
        ...findConnectionsBetween(
          scope,
          scope.ascendingSiblings(),
          "directed"
        )
      );
    } else {
      const elements = resolveAndIncludeFromMemory(target, { memory, model });
      const visibleElements = [...memory.elements];
      if (visibleElements.length === 0) {
        visibleElements.push(
          ...n$f(
            elements.flatMap((el) => [...el.ascendingSiblings()])
          )
        );
      }
      const ensureOutgoing = outgoingConnectionPredicate(model, target);
      for (const source of elements) {
        connections.push(
          ...findConnectionsBetween(
            source,
            visibleElements,
            "directed"
          ).filter(ensureOutgoing)
        );
      }
    }
    stage.addConnections(
      filterWhere(connections)
    );
    return stage;
  },
  exclude: ({ expr: { outgoing }, model, scope, stage, where }) => {
    const excluded = [];
    if (ModelFqnExpr.isWildcard(outgoing)) {
      if (!scope) {
        return;
      }
      excluded.push(...scope.allOutgoing);
    } else {
      const elements = resolveElements(model, outgoing);
      excluded.push(
        ...elements.flatMap((e) => [...e.allOutgoing])
      );
    }
    stage.excludeRelations(
      toSet(excluded.filter(where))
    );
    return stage;
  }
};
function outgoingConnectionPredicate(model, expr) {
  switch (true) {
    case ModelFqnExpr.isElementKindExpr(expr):
    case ModelFqnExpr.isElementTagExpr(expr): {
      const isElement = elementExprToPredicate(expr);
      return (connection) => isElement(connection.source);
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "children"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h(
        [...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      );
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "descendants"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h([
        Connection.isInside(fqn),
        ...[...model.children(fqn)].map(
          (el) => Connection.isOutgoing(el.id)
        )
      ]);
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      const fqn = FqnRef.flatten(expr.ref);
      return t$h([
        Connection.isOutgoing(fqn),
        Connection.isInside(fqn)
      ]);
    }
    case ModelFqnExpr.isModelRef(expr): {
      const fqn = FqnRef.flatten(expr.ref);
      return Connection.isOutgoing(fqn);
    }
    default:
      nonexhaustive(expr);
  }
}

const WildcardPredicate = {
  include: ({ scope, model, stage, memory, where }) => {
    if (!scope) {
      const rootElements = [...model.roots()].filter(where);
      if (rootElements.length === 0) {
        return;
      }
      stage.addExplicit(rootElements);
      stage.addConnections(findConnectionsWithin(rootElements));
      stage.connectWithExisting(rootElements);
      return stage;
    }
    const root = where(scope) ? scope : null;
    const children = toArray(ifilter(scope.children(), where));
    const hasChildren = children.length > 0;
    if (!hasChildren) {
      if (!root) {
        return stage;
      } else {
        const edgesWithSiblings = findConnectionsBetween(root, root.siblings());
        if (edgesWithSiblings.length === 0) {
          const parent = root.parent;
          if (parent && where(parent)) {
            stage.addExplicit(parent);
          }
        }
        children.push(root);
      }
    }
    if (root) {
      stage.addExplicit(root);
    }
    const neighbours = toSet([
      ...memory.elements,
      ...scope.descendingSiblings()
    ]);
    for (const neighbour of neighbours) {
      stage.addConnections(findConnectionsBetween(neighbour, children, "directed"));
    }
    if (hasChildren) {
      stage.addConnections(findConnectionsWithin(children));
      stage.addExplicit(children);
    }
    for (const child of children) {
      stage.addConnections(findConnectionsBetween(child, neighbours, "directed"));
    }
    return stage;
  },
  exclude: ({ scope, memory, stage, where }) => {
    if (where !== NoWhere) {
      stage.exclude(
        n$e(
          [...memory.elements],
          where
        )
      );
      return stage;
    }
    if (scope) {
      stage.exclude([scope, ...scope.descendants()]);
      return stage;
    }
    return Memory.empty(memory.scope).stageExclude(stage.expression);
  }
};

function processElementPredicate(expr, op, ctx) {
  switch (true) {
    case ModelFqnExpr.isCustom(expr): {
      if (op === "include") {
        return processElementPredicate(expr.custom.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelFqnExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterWhere = (elements) => {
        return n$e(elements, where);
      };
      return processElementPredicate(expr.where.expr, op, { ...ctx, where, filterWhere });
    }
    case (ModelFqnExpr.isModelRef(expr) && expr.selector === "expanded"): {
      return ExpandedElementPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelFqnExpr.isWildcard(expr): {
      return WildcardPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelFqnExpr.isElementKindExpr(expr):
    case ModelFqnExpr.isElementTagExpr(expr): {
      return ElementKindOrTagPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelFqnExpr.isModelRef(expr): {
      return ElementRefPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processRelationtPredicate(expr, op, ctx) {
  switch (true) {
    case ModelRelationExpr.isCustom(expr): {
      if (op === "include") {
        return processRelationtPredicate(expr.customRelation.expr, op, ctx);
      }
      return ctx.stage;
    }
    case ModelRelationExpr.isWhere(expr): {
      const where = whereOperatorAsPredicate(expr.where.condition);
      const filterRelations = (relations) => {
        return new Set(n$e([...relations], where));
      };
      const filterWhere = (connections) => {
        return t$e(
          connections,
          t$f((c) => new ConnectionModel(c.source, c.target, filterRelations(c.relations))),
          n$e((c) => c.nonEmpty())
        );
      };
      return processRelationtPredicate(expr.where.expr, op, {
        ...ctx,
        where,
        filterWhere
      });
    }
    case ModelRelationExpr.isInOut(expr): {
      return InOutRelationPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelRelationExpr.isDirect(expr): {
      return DirectRelationExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelRelationExpr.isOutgoing(expr): {
      return OutgoingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    case ModelRelationExpr.isIncoming(expr): {
      return IncomingExprPredicate[op]({ ...ctx, expr }) ?? ctx.stage;
    }
    default:
      nonexhaustive(expr);
  }
}
function processPredicates(model, memory, rules) {
  const ctx = {
    model,
    scope: memory.scope,
    where: NoWhere,
    filterWhere: NoFilter
  };
  for (const rule of rules) {
    if (isViewRuleGroup(rule)) {
      const groupMemory = ActiveGroupMemory.enter(memory, rule);
      memory = processPredicates(model, groupMemory, rule.groupRules);
      invariant(memory instanceof ActiveGroupMemory, "processPredicates must return ActiveGroupMemory");
      memory = memory.leave();
      continue;
    }
    if (isViewRulePredicate(rule)) {
      const op = "include" in rule ? "include" : "exclude";
      const exprs = rule.include ?? rule.exclude;
      for (const expr of exprs) {
        let stage = op === "include" ? memory.stageInclude(expr) : memory.stageExclude(expr);
        switch (true) {
          case ModelExpression.isFqnExpr(expr):
            stage = processElementPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          case ModelExpression.isRelationExpr(expr):
            stage = processRelationtPredicate(expr, op, {
              ...ctx,
              stage,
              memory
            }) ?? stage;
            break;
          default:
            nonexhaustive(expr);
        }
        memory = stage.commit();
      }
    }
  }
  return StageFinal.for(memory).commit();
}
function computeElementView(likec4model, {
  docUri: _docUri,
  // exclude docUri
  rules: _rules,
  // exclude rules
  ...view
}) {
  const rules = resolveGlobalRulesInElementView(
    _rules,
    likec4model.globals
  );
  const scope = view.viewOf ? likec4model.asComputed.element(view.viewOf) : null;
  let memory = processPredicates(
    likec4model,
    Memory.empty(scope),
    rules
  );
  if (memory.isEmpty() && scope) {
    memory = memory.update({
      final: /* @__PURE__ */ new Set([scope])
    });
  }
  memory = assignElementsToGroups(memory);
  const nodesMap = buildNodes(likec4model, memory);
  const computedEdges = toComputedEdges(memory.connections);
  linkNodesWithEdges(nodesMap, computedEdges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges: computedEdges
  });
  const nodes = applyCustomElementProperties(
    rules,
    applyViewRuleStyles(
      rules,
      sorted.nodes
    )
  );
  const autoLayoutRule = t$9(rules, isViewRuleAutoLayout);
  const nodeNotations = buildElementNotations(nodes);
  return calcViewLayoutHash({
    ...view,
    _stage: "computed",
    autoLayout: {
      direction: autoLayoutRule?.direction ?? "TB",
      ...autoLayoutRule?.nodeSep && { nodeSep: autoLayoutRule.nodeSep },
      ...autoLayoutRule?.rankSep && { rankSep: autoLayoutRule.rankSep }
    },
    edges: applyCustomRelationProperties(rules, nodes, sorted.edges),
    nodes: t$f(nodes, (n) => {
      if (n.icon === "none") {
        delete n.icon;
      }
      return n;
    }),
    ...nodeNotations.length > 0 && {
      notation: {
        nodes: nodeNotations
      }
    }
  });
}
function assignElementsToGroups(memory) {
  if (memory.groups.length === 0) {
    return memory;
  }
  const groupAssignments = new DefaultMap(() => /* @__PURE__ */ new Set());
  const assignedTo = /* @__PURE__ */ new Map();
  const isAncestorAssigned = (el) => {
    for (const parent of el.ancestors()) {
      const groupId = assignedTo.get(parent);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  const isDescendantAssigned = (el) => {
    for (const descendant of el.descendants("asc")) {
      const groupId = assignedTo.get(descendant);
      if (groupId) {
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
        return true;
      }
    }
    return false;
  };
  t$e(
    sortParentsFirst([...memory.explicitFirstSeenIn.keys()]),
    t$8((el) => {
      if (!isAncestorAssigned(el)) {
        const groupId = nonNullable(memory.explicitFirstSeenIn.get(el));
        assignedTo.set(el, groupId);
        groupAssignments.get(groupId).add(el);
      }
    })
  );
  t$e(
    sortParentsFirst([...memory.lastSeenIn.keys()]),
    n$e((el) => !assignedTo.has(el)),
    t$8((el) => {
      if (isAncestorAssigned(el)) {
        return;
      }
      if (isDescendantAssigned(el)) {
        return;
      }
      const groupId = nonNullable(memory.lastSeenIn.get(el));
      assignedTo.set(el, groupId);
      groupAssignments.get(groupId).add(el);
    })
  );
  if (groupAssignments.size === 0) {
    return memory;
  }
  let groups = memory.groups.map((group) => {
    const explicits = groupAssignments.get(group.id);
    if (!explicits) {
      return group;
    }
    return group.update(explicits);
  });
  return memory.update({ groups });
}

function unsafeComputeView(viewsource, likec4model) {
  switch (true) {
    case isElementView(viewsource):
      return computeElementView(likec4model, viewsource);
    case isDeploymentView(viewsource):
      return computeDeploymentView(likec4model, viewsource);
    case isDynamicView(viewsource):
      return computeDynamicView(likec4model, viewsource);
    default:
      nonexhaustive(viewsource);
  }
}
function computeView(viewsource, likec4model) {
  try {
    return {
      isSuccess: true,
      view: unsafeComputeView(viewsource, likec4model)
    };
  } catch (e) {
    return {
      isSuccess: false,
      error: e instanceof Error ? e : new Error(`Unknown error: ${e}`),
      view: void 0
    };
  }
}
function computeParsedModelData(parsed) {
  const likec4model = LikeC4Model.create(parsed);
  let {
    views: _views,
    _stage: __omitted,
    ...rest
  } = parsed;
  const views = t$q(_views, (v) => unsafeComputeView(v, likec4model));
  return {
    [_stage]: "computed",
    ...rest,
    views
  };
}
function computeLikeC4Model(parsed) {
  return LikeC4Model.create(computeParsedModelData(parsed));
}

export { t$7 as a, computeParsedModelData as b, computeLikeC4Model as c, computeView as d, n$7 as n, topologicalSortExports as t, unsafeComputeView as u, willCreateCycle as w };
