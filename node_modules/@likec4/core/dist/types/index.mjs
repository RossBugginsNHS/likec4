export { R as RichText, e as exact } from '../shared/core.M9ayqQZa.mjs';
export { preferDescription, preferSummary } from './_aux.mjs';
export { b as _layout, _ as _stage, a as _type, j as isAndOperator, n as isComputedView, d as isDeployedInstance, c as isDeploymentNode, s as isDeploymentView, o as isDiagramView, t as isDynamicView, p as isElementView, r as isExtendsElementView, f as isKindEqual, o as isLayoutedView, h as isNotOperator, i as isOnStage, k as isOrOperator, g as isParticipantOperator, q as isScopedElementView, e as isTagEqual, l as isViewRulePredicate, m as isViewRuleStyle, w as whereOperatorAsPredicate } from '../shared/core.DH7TXqXf.mjs';
export { Expression, FqnExpr, RelationExpr } from './expression.mjs';
export { ModelExpression, ModelFqnExpr, ModelRelationExpr } from './expression-model.mjs';
export { FqnRef } from './fqnRef.mjs';
import { a as t } from '../shared/core.BsSXS-_R.mjs';
import { i as invariant } from '../shared/core.D4npX2q8.mjs';
export { e as ensureSizes } from '../shared/core.DEieYfbG.mjs';
export { D as DeploymentFqn, E as EdgeId, F as Fqn, a as GlobalFqn, G as GroupElementKind, N as NodeId, P as ProjectId, R as RelationId, S as StepEdgeKind, V as ViewId, g as extractStep, f as flattenMarkdownOrString, b as isGlobalFqn, i as isGroupElementKind, e as isStepEdgeId, s as scalar, c as splitGlobalFqn, d as stepEdgeId } from '../shared/core.C_Ni6yHl.mjs';
export { g as getParallelStepsPrefix, b as isAutoLayoutDirection, d as isDynamicStep, e as isDynamicStepsParallel, f as isDynamicStepsSeries, c as isViewRuleAutoLayout, a as isViewRuleGlobalPredicateRef, i as isViewRuleGlobalStyle, h as isViewRuleGroup } from '../shared/core.BuQZczj6.mjs';

var BBox;
((BBox2) => {
  function center({ x, y, width, height }) {
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  }
  BBox2.center = center;
  function fromPoints(points) {
    const { x1, y1, x2, y2 } = RectBox.fromPoints(points);
    return {
      x: x1,
      y: y1,
      width: x2 - x1,
      height: y2 - y1
    };
  }
  BBox2.fromPoints = fromPoints;
  function merge(...boxes) {
    invariant(t(boxes, 1), "No boxes provided");
    if (boxes.length === 1) {
      return boxes[0];
    }
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const box of boxes) {
      minX = Math.min(minX, box.x);
      minY = Math.min(minY, box.y);
      maxX = Math.max(maxX, box.x + box.width);
      maxY = Math.max(maxY, box.y + box.height);
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  BBox2.merge = merge;
  function fromRectBox(rect) {
    return {
      x: Math.min(rect.x1, rect.x2),
      y: Math.min(rect.y1, rect.y2),
      width: Math.abs(rect.x2 - rect.x1),
      height: Math.abs(rect.y2 - rect.y1)
    };
  }
  BBox2.fromRectBox = fromRectBox;
  function toRectBox(box) {
    return {
      x1: box.x,
      y1: box.y,
      x2: box.x + box.width,
      y2: box.y + box.height
    };
  }
  BBox2.toRectBox = toRectBox;
  function expand(box, plus) {
    if (plus === 0) {
      return box;
    }
    return {
      x: box.x - plus,
      y: box.y - plus,
      width: box.width + plus * 2,
      height: box.height + plus * 2
    };
  }
  BBox2.expand = expand;
  function shrink(box, minus) {
    if (minus === 0) {
      return box;
    }
    return {
      x: box.x + minus,
      y: box.y + minus,
      width: box.width - minus * 2,
      height: box.height - minus * 2
    };
  }
  BBox2.shrink = shrink;
  function includes(a, b) {
    if (a === b) {
      return true;
    }
    return a.x <= b.x && a.y <= b.y && a.x + a.width >= b.x + b.width && a.y + a.height >= b.y + b.height;
  }
  BBox2.includes = includes;
})(BBox || (BBox = {}));
var RectBox;
((RectBox2) => {
  function center({ x1, y1, x2, y2 }) {
    return {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    };
  }
  RectBox2.center = center;
  function fromPoints(points) {
    invariant(points.length > 0, "At least one point is required");
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const [x, y] of points) {
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }
    return {
      x1: minX,
      y1: minY,
      x2: maxX,
      y2: maxY
    };
  }
  RectBox2.fromPoints = fromPoints;
  function merge(...boxes) {
    invariant(boxes.length > 0, "No boxes provided");
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const box of boxes) {
      minX = Math.min(minX, box.x1);
      minY = Math.min(minY, box.y1);
      maxX = Math.max(maxX, box.x2);
      maxY = Math.max(maxY, box.y2);
    }
    return {
      x1: minX,
      y1: minY,
      x2: maxX,
      y2: maxY
    };
  }
  RectBox2.merge = merge;
  function toBBox(box) {
    return {
      x: box.x1,
      y: box.y1,
      width: box.x2 - box.x1,
      height: box.y2 - box.y1
    };
  }
  RectBox2.toBBox = toBBox;
  function includes(a, b) {
    if (a === b) {
      return true;
    }
    return a.x1 <= b.x1 && a.y1 <= b.y1 && a.x2 >= b.x2 && a.y2 >= b.y2;
  }
  RectBox2.includes = includes;
})(RectBox || (RectBox = {}));

function isTagColorSpecified(spec) {
  const color = typeof spec === "string" ? spec : spec.color;
  return color.startsWith("#") || color.startsWith("rgb");
}

export { BBox, RectBox, isTagColorSpecified };
