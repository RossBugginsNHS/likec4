import { w as willCreateCycle, t as topologicalSortExports, a as t$2, n as n$1 } from '../shared/core.23WeDKcI.mjs';
export { c as computeLikeC4Model, b as computeParsedModelData, d as computeView, u as unsafeComputeView } from '../shared/core.23WeDKcI.mjs';
import { n } from '../shared/core.CHwVhuc9.mjs';
import { t, a as t$1 } from '../shared/core.h4TqqSC0.mjs';
import { r as isExtendsElementView, p as isElementView } from '../shared/core.DH7TXqXf.mjs';
import { G as Graph } from '../shared/core.DrUt0Lbi.mjs';
import { c as isNonEmptyArray } from '../shared/core.6VsRBhGY.mjs';
import { t as t$3 } from '../shared/core.CbT8JVYL.mjs';

function resolveRulesExtendedViews(unresolvedViews) {
  const g = new Graph({
    type: "directed"
  });
  const extendedViews = [];
  for (const view of t(unresolvedViews)) {
    g.addNode(view.id, { view });
    if (isExtendsElementView(view)) {
      extendedViews.push(view);
    }
  }
  if (extendedViews.length === 0) {
    return unresolvedViews;
  }
  for (const view of extendedViews) {
    if (!g.hasNode(view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which does not exist`);
      continue;
    }
    if (willCreateCycle(g, view.id, view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which creates a cycle`);
      continue;
    }
    g.addDirectedEdge(view.id, view.extends);
  }
  const sorted = topologicalSortExports.topologicalSort(g).reverse();
  return sorted.reduce((acc, id) => {
    const view = g.getNodeAttribute(id, "view");
    if (!isExtendsElementView(view)) {
      acc[view.id] = view;
      return acc;
    }
    const extendsFrom = acc[view.extends];
    if (!extendsFrom || !isElementView(extendsFrom)) {
      return acc;
    }
    const tags = n([
      ...extendsFrom.tags ?? [],
      ...view.tags ?? []
    ]);
    const links = [
      ...extendsFrom.links ?? [],
      ...view.links ?? []
    ];
    acc[view.id] = {
      ...extendsFrom,
      ...view,
      title: view.title ?? extendsFrom.title ?? null,
      description: view.description ?? extendsFrom.description ?? null,
      tags,
      links: isNonEmptyArray(links) ? links : null,
      rules: [...extendsFrom.rules, ...view.rules]
    };
    return acc;
  }, {});
}

function withReadableEdges({ edges, nodes, ...view }, separator = ":") {
  const edgeids = t$2(edges, (e) => [e.id, `${e.source}${separator}${e.target}`]);
  return {
    ...view,
    edges: edges.map((e) => ({
      ...e,
      id: edgeids[e.id]
    })),
    nodes: nodes.map((n) => ({
      ...n,
      inEdges: t$3(n.inEdges, (e) => edgeids[e]),
      outEdges: t$3(n.outEdges, (e) => edgeids[e])
    })),
    nodeIds: nodes.map((n) => n.id),
    edgeIds: edges.map((e) => edgeids[e.id])
  };
}
function viewsWithReadableEdges({ views, ...model }) {
  return {
    ...model,
    views: t$1(views, (v) => n$1(withReadableEdges(v), ["nodeIds", "edgeIds"]))
  };
}

export { resolveRulesExtendedViews, viewsWithReadableEdges, withReadableEdges };
